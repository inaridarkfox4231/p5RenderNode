// テクスチャとセーブ
// テクスチャ
// まずp5.Imageとnew Image()とcreateGraphicsで作るimageのいずれからでも作れるようにする。
// それぞれの作り方はこんな感じ：
/*
let _loaded;
let img = new Image();
img.onload = function(){
  console.log(this.width, this.height); // 256, 256. 通常サイズ。当然か。
}
img.src = "https://inaridarkfox4231.github.io/assets/texture/rdm.png";

function preload(){
  _loaded = loadImage("https://inaridarkfox4231.github.io/assets/texture/cloud.png");
}

function setup() {
  createCanvas(400, 400);
  let gr = createGraphics(100,100);
  // これはもちろん100,100になる。
  // texture作るのにこの値を用いてはいけない。gr自身は、
  // テクスチャの引数になることはできないのだ。
  console.log(gr.width, gr.height); // 100, 100.
  console.log(gr.elt.width, gr.elt.height); // 200, 200 2倍サイズ
  console.log(_loaded.canvas.width, _loaded.canvas.height); // 256,256 通常
  // このように、p5.Graphicsを使う場合だけ、2倍になる。
  // そしてこれらのeltだったりcanvasだったりimgだったりが
  // texImage2Dの最後の引数の資格を持つ。

  // ImageElementもしくはCanvasElementがtexImage2Dの引数としての
  // 資格を持ち、そのwidth,heightを使う場合、p5.Graphicsだけ値が意図した
  // 値の2倍とかになるので困るわけ。
  console.log(gr instanceof p5.Graphics);
  console.log(_loaded instanceof p5.Image);
  console.log(gr.elt instanceof HTMLCanvasElement);
  console.log(_loaded.canvas instanceof HTMLCanvasElement);
  console.log(img instanceof HTMLImageElement);
  const testArray = new Uint8Array(4*100*100);
  console.log(testArray instanceof Uint8Array);
}

function draw() {
  background(220);
}
*/

// テクスチャの作り方
// っていってもframebufferんとこに書いてあるんだからそれをなぞるだけなのよ、基本。

// 0. createTextureでテクスチャオブジェクト生成
// 1. 各種設定の準備のため一時的にbind
// 2. 書き込みの仕様を決めるためにformat設定、幅と高さの設定、さらに画像データがあるならそれを設定、無ければnull.
//    p5js公式は1x1のUint8Arrayを使ってるけどサイズが確定してる場合この方法は使えません。h_doxasさんは読み込み...
//    前提でやってますね。あの記事は2Dでいろいろやることを想定していないので読み込み以外ありえないのです。
//    先ほども説明したようにp5.ImageもしくはHTMLImageElementの場合は同じなんですがp5.Graphicsの場合そのcanvasは2倍サイズ
//    なので注意です。
// 3. フィルタ設定。場合によってはmipmapがtrueになっていてLINEAR_MIPMAP_LINEARを設定する...かも？
// 4. ラッピング設定。範囲外のUV値に対してどうふるまうか。いわゆるシームレステクスチャの場合ここをrepeatにする。
// 5. 終わったのでbindを解除。お疲れさまでした。createしたtextureにはアクセスできるようにしておこう。
// で、終わりなんですが、メソッドでフィルタやラッピングを変更できるメソッドも一応用意しておこう。
// さらにupdateといってsrcというか

// p5.Graphicsから構成する場合は特殊ケースとみなした方が良さそうだ。テクスチャ単独で使う場合はいいけれど。
// これをあえて切り離して、grに手を加えたうえでそのたびにupdateが実行されるようにしよう。return thisでchainで。
// 要するにbgManagerの復活というわけね。getGraphicsで取得してあれこれする、updateする。
// updateの場合はおそらくだけどtexSubImage2DでOKのはず。
// さらにこれらとは別に第3のケースとしてフレームバッファのtextureの初期設定に画像データを仕込めるようにする。

// UInt8Array → Uint8Array.

// 4つくらいで。んでこれらが用いられ...Uint8Arrayの場合すでにwとhが想定されてて何かしらの方法で4*w*hの長さになってたりする...
// ので、wとhはそのままで、って感じで。

// gl.RGBA32F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.HALF_FLOAT
// gl.RGBA --- gl.RGBA --- gl.UNSIGNED_BYTE
// gl.R32F --- gl.RED --- gl.FLOAT

// せいぜいこんくらいだろ。
// ちなみになぜメモ帳なのに「//」で始めてるかというと
// ソースコードに貼り付けるときに便利だから。まあ最初//で書いてたのを移して、惰性、だけどね。

// やっぱp5.Graphicsだけ特別扱いするのは、無しで。めんどくさい。

// フレームバッファのクラス化が出来れば、その内部のテクスチャにアクセスして、ラップとかいじれるし（いじる機会なさそうだけど）、
// ...どうしよ。

// framebufferのinfoでsrcってやってこれを初期設定できるかどうか確かめる。
// 20221017
// だめ。他の変数が使えない。
// やっぱソース取得とupdateそれぞれ用意して。
// あとtextureのupdateも隠蔽しよう。

/*
  イメージ：
  const gr = _node.getTextureSource("hoge");
  ~~~~~~ grであれこれ ~~~~~~
  _node.updateTexture("hoge");
*/

// 簡単でしょ！？さて、動くかどうかテストだ...しんどいわ...
// まあこんな感じなんで、「texture早く実装してよ！」って言われても、無理なんですよ。考えないといけないことが山ほどある。
// のちのちの仕様変更とかも考えるとうかつに動けないわけ。お分かりですかね...？

// やること。
// 1. Textureの生成関数をまとめる。fbのクラス化はおそらくあまりメリットが無いので。MRT導入の際冗長になるのを避けたい。
// 2. Textureのテスト。通常の生成で一通り描画できるか調べる。コピーシェーダ使う感じで。
//    ていうか4つ全部作ってChannelで4つまとめて表示すればいいんだ。多分。
// 3. Textureの動的更新のテスト。
// 4. framebufferの初期値としてテクスチャを設定できるかテスト
// あ、そうそう、framebufferの生成でdepthとtextureそれぞれ作ったうえで、フレームバッファを生成、っていうのがメジャーな作り方らしい。
// そこら辺若干コード修正よろしくね。

// レンダーバッファ分からん！！
// ただディファードでデプスは仕事してたのでそういうことじゃないんだろう。
// デプスがうまく使えるようになれば距離フォグとかできるし早く実装したいわね
// フレームバッファのデプス部分を「レンダーバッファ、無し、テクスチャ」みたいな感じで選べるようにしたい。
// そうしたら...
// 内容が分からないので相当テストが要るわね。

// clearはRenderbufferにも適用されるよ...じゃなきゃあそこの修正が意味をなさないでしょう。
// 多分、framebufferのbindでtexture, renderbuffer, 双方が自動的にbindされる仕組みなのよね。
// ああなるほど...framebufferってそういうことか...まさに、「枠組み」なんだわ。まさに、フレーム。フレームバッファなんだわ。
// depthの内容わけわからんからテストしないと駄目じゃな。
// pointSpriteの動きとかで可視化できるといいんだけどな。

// ごめんなさい間違えた。これで...いいんだ！？
// つまりデプスと色用意したら後はそれをフレームバッファに関連付ける際にバインドはもうしなくていいんだ、すげぇな！

// クリアするパートやめた。これもpavelさん真似したんだけど、まあ、要らないかな...って思ったので。
// infoどうするかって話。
// info:{depth:{},color:{},stencil:{}}
// それぞれレンダーバッファとテクスチャの2つの選択肢がある。選ばない方法もある。そういう話。
// もしくはcolorInfo = {}, depthInfo = {}, stencilInfo = {} でも良さそう？かぶらない。
// attachTypeのデフォルトをそれぞれ"renderbuffer", "texture", "none"（ステンシルは用意しない）にする。
// attachType: "renderbuffer":レンダーバッファとして用意する。"texture":テクスチャとして用意する。"none":用意しない。
// で、こうする。
// info:{w:256, h:256,
//       depth:{attachType:"renderbuffer", info:{}},
//       color:{attachType:"texture", info:{}}, // だからここを配列にしてArray.isArrayで場合分けすればいいんだよな
//       stencil:{attachType:"none", info:{}}};
// これで。そうすれば従来通りinfoは使えるし...いろいろ問題ない、はず...stencilはいつかのために。これも使い道分からんのよ。

// MASKは書き込みされるかどうかを決める
// TESTは書き込んだ値を使うかどうかを決める
// そういうことだと思う。つまりframebuffer作る際にレンダーバッファとしてステンシルを用意すればそれが（ピッキングとかで）
// 使えるようになるんだと思いますよ。いつかね...

// で、おそろしいことにこうするとですね...
// textureFormat → format
// 全部「texture」が不要になるんですねぇ！！（ひぇ...）
// あとvalidate関数がgl要らないのでgl使ってたから消しておいたよ
// おそらくもともとはgl定数にする処理だったんだけどそれだといろいろとめんどくさいということでやめたんだろう。

// あと返り値ですけど、Renderbufferですけど、要らんよね。
// で、今までフレームバッファからなんか取り出すときってテクスチャが一枚だったけど、
// これからは複数だったり、デプスも...とかだったりするから、名前で管理して指定できるようにしないとねぇ。
// そうですね
// てか複数...それでいける、のか？

// Array.isArrayで配列かどうか調べられるからそれでチェックして
// 名前は0,1,2の通し番号で、もしくは具体的に名付け...られる方がいいかな...
// 名前はテクスチャだけでいいです、使うのはテクスチャ。
// 配列化できるのも色だけ。drawBuffersで入れる。可能なのは色だけ！です。
// 配列化できるのは色だけ！！（重要）ということはtextureは関係なくて、色ということが重要なのね。
// Renderbufferも対象外だし。「色」で、「テクスチャ」。はい。了解！！
// あと名前で管理すれば完璧だわね。

// wとhは全部同じでいいよ、ていうか同じでしょう。レジストフレームバッファでコピーすればいい。
// あとtextureはnameを忘れずに指定。これで、いける！
// validationでwとhをコピーしてもいいけど冗長になるからなぁ。回避！

// ダブルフレームバッファについて、それぞれinfoを用意するように仕様変更します。{read:{}, write:{}}って感じで。

// {read:{color:{info:{name:"t", type:"float", filter:"linear"}}},
//  write:{color:{info:{name:"t", type:"float", filter:"linear"}}}}
//  って感じになるわね。nameは何でもいいけど同じじゃないとswapの際に問題が発生するわね。
// setFBOtexture2Dもほぼコピペだから修正必須なのよね。
// というのもこっちでfboを扱わないので。
// validationでdepthは自動的にRenderbufferになるしstencilはnoneになるし
// attachTypeも指定が無ければ勝手に用意される。
// wとhも勝手に上から引き継がれる。何もしなくていい。
// いやあれ、ダブルの場合、assignが使えないから、それぞれ用意しようかと。手間だけど汎用性考えたらメリットしかないので。

// ...？？？

//
// 何でもない
// サンプルでbindFramebufferしてるのでbindTextureしてないからおかしいなって思って。
// 予測だけど
// ああいう管理の仕方ならbindTextureは不要ということなのかもしれない
// 今現在の理解ではshaderごとにsamplerIndexを0ベースにして異なるようにすればいいって感じになってるんだけど
// それでいくとあそこは両方とも0になっちゃうんだよ
// 当たり前だよなひとつしかテクスチャ使ってないんだから
// MRTのサンプル！
// なのにあれ、1と2って分けてる。しかも0ってやると画像が出る。板ポリ芸だからな。
// んー...

// 関係ないけどデプスを放り込むの、(z/w + 1)/2 で用意に0～1にできるのな...それはそうだけどさ、だったらさ、
// デプステクスチャ、要らねーじゃん！！（要らねー...）
// WEBGL1のMRTのコード、チャンネルわけの仕方興味深い。真似したいかも。
// そしてこっちもbindTextureは使ってませんね...

// 現在の予想：
// shaderごとに0ベースでindexを付けるならbindTextureを使う。
// それをしないなら全体で同じテクスチャごとに違うindexを使う。と。
// 個人的には、いちいちbindTexture使うことによって通し番号を意識したコード書かなくてよくなるならそっちの方がいいな。
// だってめんどくさい！！！！

// ってわけでこの記事：https://webglfundamentals.org/webgl/lessons/ja/webgl-2-textures.html
// まあそういうことみたいですね...
// ただあれ：https://qiita.com/inaba_darkfox/items/6894b4fd54a9dacacf96
// これの解決にはなってないかな...というかこれ、もうわけわかんなくなってる。処理が隠蔽されすぎなのよね。
// どのシェーダ使ってるかとかめちゃくちゃだし。
// そこで再現します。2つのやり方で。説明としては、それが一番かと。

// さっきの話。
// まず整理すると、テクスチャユニットというのがあって配列だと。で、activeTextureはいわゆるcurrentIndexを定めている、
// bindTextureで「そこ」にtextureをセットできる。だからnullをセットするっていうのは空にする行為なのね。
// で、uniform1iはプログラムごとのロケーションにそのテクスチャ配列内のテクスチャを番号で取得するわけだ。
// 配列からのランダムアクセスみたいな感じで。
// だから事前にactiveだのbindだのしておけばレンダリングの際にはuniform1i呼ぶだけで済むわけ。
// PavelさんのCodePen流体がこの方法を用いていた...ようです。

// ところが、Bloom流体となると...p5jsのように、プログラムごとに...ってやってる。
// 書き換え自体は楽なのよね。通し番号付けるだけだし...テクスチャに。で、その番号を使えばいいわけだから。
// ただまあ、書き換えるのめんどくさいし、Pavelさんっていうオーソリティがいるわけだし。p5jsも。
// そりゃパフォーマンスに致命的影響あるなら考えるけど...Pavelさんのあれヌルヌルだしな。
// 今のままで行きます。

// 実験はするけど。

// 流れ
// Texture実装したので色々テスト（現在の仕様で。マルチテクスチャどんとこいで）
// 先ほどの議論について割と派手な検証をする
// framebufferの入力infoをいじる。Textureには名前を付けて管理、というかTextureExにしよう。これでいく。
// （今後はframebufferからテクスチャを取り出す場合はテクスチャの名前も指示することとする。）
// （マルチとか役割ごとに違う名前の方が分かりやすいでしょう。指定順とシェーダーの順を合わせないと...）
// （一部のテクスチャにしかレンダリングされないのとか出来るんだろうか？調査中。）
// （ダブルの場合は特殊事情ということで同じ名前にする。というか"t"で固定でいいと思う。どうせどっちかしか使わないのだ。）
// （流体のでwriteを使うみたいなのあったっけ...？いいよ、気が向いたらで。）
// framebufferを規定の画像で初期化するのもやりたいね。
// depthの可視化はh_doxasさんの方法でいいんじゃないかな...デプステクスチャの方法とどっちがいいのか確かめたいわね


// 生成の際にdictが必要になると分かったので追加。
// あー、そうね..._textureがstringならこれ入れないとだわね。

// よくわかんないけどcross-originっていうのがあって
// https://developer.mozilla.org/ja/docs/Web/HTML/CORS_enabled_image
/*
img.onload = function(){
  this.crossOrigin = "Anonymous"; // crossOrigin大事ね
}
*/
// こうすることで問題なくロードできるようです。new Image()でやる場合はこうするそうですね。

// framebufferのdoubleについて。
// まず複製はしなくていいです。同じもの使っていい。よく考えたら何の問題も無かったわ。
// 検証は無しで。めんどくさい。uniformのlocation隠蔽しちゃったのよ。

// 新しいframebuffer生成の際のinfo.
// 頑張って！
/*
info = {w:~~, h:~~, depth:{}, color:{}, stencil:{}}
nameも持つが登録の際にinfoに付与するのでいちいち書く必要はない。
wとhは必須。当たり前。
depthとstencilは無い場合はvalidationで勝手に
depth:{attachType:"renderbuffer", info:{}}
stencil:{attachType:"none"}
が付与される。attachTypeは"renderbuffer", "texture", "none"の3種類があり種類に応じてinfoにvalidationが掛けられる。
infoのvalidationの掛け方はもう決まっている。
*/

// doubleも同じ、全く同じinfoを用いていい（複製なんかするかよ）
// colorのinfoは配列を取れる。それはtextureInfoの配列。つまり「color」かつ「texture」の場合のみ配列が許される。
// それでマルチ（以下略）

// 名前で管理しなくていいや。配列なんだからインデックスで管理しよう。
// 必要ならネームリストを用意すればいいだけの話。煩雑さは避けたい。textureInfoは名前を持たない設定...

// テクスチャクラスにする必要ないな。どうせフィルタとかいじらないで使うんだから。
// ...いじることになったら
// doubleは配列とは両立しない...使い道が見つかったらやるかもしれないけど。いや、うーん...
// そうね～AとBからAとB...できたら面白いかもだね。

// registFBOとregistDoubleFBOは変えるとこなさそう。
// setFBOtexture2Dで、
// というわけでfbo.tとかfbo.read.tが配列の場合を考慮した仕様変更終わり。
// あとはinfoの指定の仕方を変えて、またcolor-textureの場合に配列を許すようにすれば完成。簡単？

// あー、駄目だわ。
// depth, color, stencilってなるからさ。
// そういうわけで、未定義ならkind:color, さらに未定義ならindex:0としよう。

// framebufferっていうより frame of buffer の方がしっくりくるわね。

// ああ...validateに必要なのはinfoだけだよ...馬鹿...
// ごめん。attachTypeなかったら判断出来ないわ。

// 何だもう終わりか。ちょろい。

// 細かいこと言うね。textureのパラメータで「texture～～」の「texture」はもう不要だから
// 取ってしまおう。うざい。
// texture用であることがattachTypeでわかってるんだから強調する必要ないんよ。

// framebuffer終わりました。疲れた...
// MRTの簡単なテストは...また今度。

// 明日はとりあえず過去作でTexture使ってるところを書き換えるのと
// いよいよMRTを実装しましょう。

// wとhは指定が無ければsrcの取得時に付与されるようにしようか（ただしsrcがnullでないことが前提）
// めんどくさくなってきた。何でいちいち「elt」って書かないといけないのか。
// srcがnullでなければwとhは自動的に設定されるように仕様変更

// 関数名そのまま書いちゃった～関数()ってしないといけないところを～～
// こういうのほんといやだ
// copyProgramは必要な時だけ使おう

// じゃあ配列対応よろしくね（え？？）

// 要はinfo.color.infoが配列の場合の分岐処理です、難しくないよ！！

// 配列対応しました。あとdrawBuffersとテストコードで完成ですかね。
// MRTのテストとデプスとステンシルのが終わったらいよいよ実線投入？
// いやいや、H3foldも残ってるしKomatebeさんのブラクラも...tfとcameraの統合...ライティング...うぉぅ...きつい...

// ライティングもデフォルトシェーダあるといいね
// アイデアとしてはp5のは色々盛り過ぎなので#defineで整理したい

// テクスチャについて基本的なこと。
// imageとかで放り込む場合左上が(0,0)になるようにピクセルを配置するとそのままの形で表示されます。
// これを「左上が(0,0)」と呼んでいるわけ。
// ところがたとえばレンダリングでテクスチャに描画する場合などは左下が(0,0)として書き込まれるんですね。
// それが単純に(0,0)～(w,h)って感じで格納されるので
// それをimageとかと同じように表示すると上下が逆になってしまうわけ。
// ...結論。「copyProgramのオプションで上下順方向できるようにしよう」。よろしく！

// レンダリング結果をそのまま転送する場合も多いだろうからね。

// というわけでcopyProgramの方はflip=trueデフォ、copyProgramFBOの方はflip=falseデフォでいこう。
// ていうかあれ、ディファードレンダリングでもflipしなかったでしょ？

// というわけでreadPixelsする場合は...レンダリング結果からのreadPixelsの場合はマウス座標にそれぞれ0.5を
// 足したうえでyだけ幅から引く。これでいこう。

// めんどくさいな、統一しよう。copyProgramひとつでいいよ。めんどくさい。
// {dst:{type:"fb"/null, name:"hoge"},
//  src:{type:"tex"/"fb", name:"aho", flip:true/false, attach:"color", index:0},
//  blend:true/false, blendOption:{src:"src_alpha", dst:"one_minus_src_alpha"},
//  depth:false/true} // ノーブレンドでデプスオフだと背景描画になるわけ。
// あと2つ作って。TwinとQuadかな。
// 2つなら2つ、4つなら4つ分のsrcParameterを用意する感じ。早い話がsrcだけ配列にするということ。

// texture手ごわいですね～～～

// Twinは2つ用意する。引数で大きさの割合を指定して対角線上に配置する(0.1～0.9まで変化)。
// Quadはsrcの長さ1～4に応じて最大4つまで画面内に配置する。左上、右上、左下、右下。

// せっかくfbもセットできるんだし、fbに落とすテストもしてみたいね。fbに落として...それからnullに落とす。
// その過程で何かすればポストエフェクトになるわけ。オフスクリーン、レンダリング。
// おそらくbloomを実装する過程でこれをやる。たとえば3Dでトーラスかなんか描画してcopyでfbに落として....

// MRTできたよ。あっさり。
// copyPainterなんだけどviewportいじれるように仕様変更できないかな。できるでしょ。やって。

// 20221020
// copyPainter, viewportをいじる仕様変更。なお比率指定。nullの場合は...
// getDrawingBufferSizeについて、nullでない場合にそのサイズを返すようにしますか。
// そんで比率を掛けて自由に描画場所をいじれるようにする。

// 20221020
// MRT成功です。🎉
// で、基本すべてアクティブでOKです。あれfbに対する命令なので。
// 一応関数作る。BACKはなんかよくわからんから保留で。
// あー...そうね、まあ、そうね...付与するか。付与してなかったわ、MRTの情報。フラグ付与しました。
// まあいちいちcolorにアクセスして配列かどうか調べるの手間だし仕方ないね。
// 不要論もあるでしょう。ただね。用意する時点でMRT用かどうかは意識するものよ。後から用意することもできるけど
// 不自然だし、一つでいいならMRT不要やろ。基本2つ以上で運用するんだから。
// そういうわけで。

// さてと。MRTで書き換えないといけないコードが2つ。ひとつはこないだのピッキング。ひとつはこないだの爆速。

// MRTピッキング成功しました。だいぶtextureの扱いに習熟してきましたね。
// 帰ったらcopyPainterの変種作るか。2枚とか3枚4枚とか。もしくはカスタムフォーマットでも面白いわね。その方がいいのかも？
// 1回でやりたい。2回3回とかダサいし。1回の方がかっこいいだろ。

// spotLightは光の減衰と照射範囲からの減衰を両方考慮して掛け算するようです。
// 掛け算の対象は他のライティングと一緒。しかしAttenuation全部一緒なのか...光による影響だからみんな一緒、そういうことなんかね

// はい。viewport設定分かりづらいのでいじります。0～1で指定する、やることは簡単。
// まずyにたいして1-h-yを取る。あとは比率に応じて調整。おわり。そんだけ！？そんだけ。
// 下から上に並ぶコンテンツなんてありえないでしょ。上から下の方が自然。

// って思ったけどまあ、LEFTとかTOPとかあるしな。じゃあこうしよう。
// LEFT,TOP,RIGHT,BOTTOM,CENTERでやろう。
// setViewportだけそういう形にするのか...それとも。まあそこは、ね。
// グローバル内部汎用関数で左下ベースの形式に変換すればいい。それをあちこちで使えば変な変換しなくて済む。

// LEFT指定：xそのまま。RIGHT指定：x=1-w-x. TOP指定：y=1-h-y. BOTTOM指定：この場合y=1-yですね。理由は左上ベースで考えたいから。
// CENTER指定(x)：x-=w/2. CENTER指定(y)：1-(y+h/2). こんな感じ。textみたいに2つ指定してこれにより
// 左下から上と右に...です。

// quadCopyPainterは断念します。
// 理由：分かりづらい。分かりづらいものは要らない。

// copyShaderを改良して最大16個まで用意できるようにしましょう
// indexを4つずつ同じものを用意してchannelごとにordinary UVを付けて
// それをデータを元に変換する
// 全部同じshaderでやりましょう
// drawArraysの引数を0,4*個数にすれば余分なキャンバスは描画されない。
// viewportは0,0,1,1固定でOK

// 20221021
// エラーの原因が分かった。gl_Positionの値って右側に置けないんだ。
// 気を付けましょう...

// あー、mipmapが作成されてないからエラーになる...後でやらないといけないのか。
// ああ？？？？？ミップマップが作成されない？？？？？？？？？？

// だめだ。また今度考えよう。

// もし仮にたとえばpavelさんのテクスチャ、あっちではエラーが生じるなら
// 原因はp5jsサイドにある。

// 20221021.
// TODO. 詳細はmemo.txtの方で。

// 思考が中断されました。以上。

// ああそうか。foxParseだっけ。気が向いたら組み合わせようか。
// たとえばトリガーが引かれると一定距離移動して止まる、またトリガーが引かれると一定距離移動して止まる、最初に戻る、
// そういうのを延々と繰り返すみたいなのを楽に作れるんよ。そのために作ったんだから。それと動的更新組み合わせれば...
// なのに...
// カメラのfovとかaspectとかnearとかfarとか可視化しよう、とかあるいはnearとfarを動かす関数とかあるといいかもとか
// だった気がするけどよく考えたら直接変更出来たわ（...ねぇ。）
// サイズ変更、カメラのaspect比変えるだけでいいからWEBGLほんと楽でいいねっていう話でした（OK)

// foxParseについて。
// うわぁ...もう寝る時間なのに...
// 雑感。
// うん。使いづらい。
// ていうか変なところにこだわりすぎて意味不明になってる。マルチスレッドにしてもあんま意味ないっていうか。
// もっと単純化して贅肉をそぎ落とせばいいと思う。いろいろ盛り過ぎてタコツボみたいになってしまってるので。
// それとパースに時間かかりすぎて別の意味でボトルネックになってしまってるのも巨大なマイナスポイント。
// 正直使うんだったらパースのところを全面的に書き直すべきかな。以上。時間ないのでこの辺で。BYE!!
// （ていうかsetやaddだけでよかったものを贅沢にしすぎてしっぱいしてるっていうか...関数盛り込むにしてももうちょっと
// わかりやすくすべき、あと時間ベースで書きたいかな、まあ無理だろうけど、fpsに寄らない挙動書けるとかっこいいし便利だし。
// でもまあ一番のマイナスポイントは「パース部分を見直してない」ということ。思考停止は悪。肝に銘じとけ。
// てかパースいじる気ないなら復活させる価値ないだろ。p5wgexだって一から作り直したっていうのに。）
// てか...javascriptしか使ってないっていうならいっそCanvasのシステムだけで作ればよかったのでは？？（とかいって～）
// p5js重いからね。
