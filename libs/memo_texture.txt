// テクスチャとセーブ
// テクスチャ
// まずp5.Imageとnew Image()とcreateGraphicsで作るimageのいずれからでも作れるようにする。
// それぞれの作り方はこんな感じ：
/*
let _loaded;
let img = new Image();
img.onload = function(){
  console.log(this.width, this.height); // 256, 256. 通常サイズ。当然か。
}
img.src = "https://inaridarkfox4231.github.io/assets/texture/rdm.png";

function preload(){
  _loaded = loadImage("https://inaridarkfox4231.github.io/assets/texture/cloud.png");
}

function setup() {
  createCanvas(400, 400);
  let gr = createGraphics(100,100);
  // これはもちろん100,100になる。
  // texture作るのにこの値を用いてはいけない。gr自身は、
  // テクスチャの引数になることはできないのだ。
  console.log(gr.width, gr.height); // 100, 100.
  console.log(gr.elt.width, gr.elt.height); // 200, 200 2倍サイズ
  console.log(_loaded.canvas.width, _loaded.canvas.height); // 256,256 通常
  // このように、p5.Graphicsを使う場合だけ、2倍になる。
  // そしてこれらのeltだったりcanvasだったりimgだったりが
  // texImage2Dの最後の引数の資格を持つ。

  // ImageElementもしくはCanvasElementがtexImage2Dの引数としての
  // 資格を持ち、そのwidth,heightを使う場合、p5.Graphicsだけ値が意図した
  // 値の2倍とかになるので困るわけ。
  console.log(gr instanceof p5.Graphics);
  console.log(_loaded instanceof p5.Image);
  console.log(gr.elt instanceof HTMLCanvasElement);
  console.log(_loaded.canvas instanceof HTMLCanvasElement);
  console.log(img instanceof HTMLImageElement);
  const testArray = new Uint8Array(4*100*100);
  console.log(testArray instanceof Uint8Array);
}

function draw() {
  background(220);
}
*/

// テクスチャの作り方
// っていってもframebufferんとこに書いてあるんだからそれをなぞるだけなのよ、基本。

// 0. createTextureでテクスチャオブジェクト生成
// 1. 各種設定の準備のため一時的にbind
// 2. 書き込みの仕様を決めるためにformat設定、幅と高さの設定、さらに画像データがあるならそれを設定、無ければnull.
//    p5js公式は1x1のUint8Arrayを使ってるけどサイズが確定してる場合この方法は使えません。h_doxasさんは読み込み...
//    前提でやってますね。あの記事は2Dでいろいろやることを想定していないので読み込み以外ありえないのです。
//    先ほども説明したようにp5.ImageもしくはHTMLImageElementの場合は同じなんですがp5.Graphicsの場合そのcanvasは2倍サイズ
//    なので注意です。
// 3. フィルタ設定。場合によってはmipmapがtrueになっていてLINEAR_MIPMAP_LINEARを設定する...かも？
// 4. ラッピング設定。範囲外のUV値に対してどうふるまうか。いわゆるシームレステクスチャの場合ここをrepeatにする。
// 5. 終わったのでbindを解除。お疲れさまでした。createしたtextureにはアクセスできるようにしておこう。
// で、終わりなんですが、メソッドでフィルタやラッピングを変更できるメソッドも一応用意しておこう。
// さらにupdateといってsrcというか

// p5.Graphicsから構成する場合は特殊ケースとみなした方が良さそうだ。テクスチャ単独で使う場合はいいけれど。
// これをあえて切り離して、grに手を加えたうえでそのたびにupdateが実行されるようにしよう。return thisでchainで。
// 要するにbgManagerの復活というわけね。getGraphicsで取得してあれこれする、updateする。
// updateの場合はおそらくだけどtexSubImage2DでOKのはず。
// さらにこれらとは別に第3のケースとしてフレームバッファのtextureの初期設定に画像データを仕込めるようにする。

// UInt8Array → Uint8Array.

// 4つくらいで。んでこれらが用いられ...Uint8Arrayの場合すでにwとhが想定されてて何かしらの方法で4*w*hの長さになってたりする...
// ので、wとhはそのままで、って感じで。

// gl.RGBA32F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.HALF_FLOAT
// gl.RGBA --- gl.RGBA --- gl.UNSIGNED_BYTE
// gl.R32F --- gl.RED --- gl.FLOAT

// せいぜいこんくらいだろ。
// ちなみになぜメモ帳なのに「//」で始めてるかというと
// ソースコードに貼り付けるときに便利だから。まあ最初//で書いてたのを移して、惰性、だけどね。

// やっぱp5.Graphicsだけ特別扱いするのは、無しで。めんどくさい。

// フレームバッファのクラス化が出来れば、その内部のテクスチャにアクセスして、ラップとかいじれるし（いじる機会なさそうだけど）、
// ...どうしよ。

// framebufferのinfoでsrcってやってこれを初期設定できるかどうか確かめる。
// 20221017
// だめ。他の変数が使えない。
// やっぱソース取得とupdateそれぞれ用意して。
// あとtextureのupdateも隠蔽しよう。

/*
  イメージ：
  const gr = _node.getTextureSource("hoge");
  ~~~~~~ grであれこれ ~~~~~~
  _node.updateTexture("hoge");
*/

// 簡単でしょ！？さて、動くかどうかテストだ...しんどいわ...
// まあこんな感じなんで、「texture早く実装してよ！」って言われても、無理なんですよ。考えないといけないことが山ほどある。
// のちのちの仕様変更とかも考えるとうかつに動けないわけ。お分かりですかね...？

// やること。
// 1. Textureの生成関数をまとめる。fbのクラス化はおそらくあまりメリットが無いので。MRT導入の際冗長になるのを避けたい。
// 2. Textureのテスト。通常の生成で一通り描画できるか調べる。コピーシェーダ使う感じで。
//    ていうか4つ全部作ってChannelで4つまとめて表示すればいいんだ。多分。
// 3. Textureの動的更新のテスト。
// 4. framebufferの初期値としてテクスチャを設定できるかテスト
// あ、そうそう、framebufferの生成でdepthとtextureそれぞれ作ったうえで、フレームバッファを生成、っていうのがメジャーな作り方らしい。
// そこら辺若干コード修正よろしくね。

// レンダーバッファ分からん！！
// ただディファードでデプスは仕事してたのでそういうことじゃないんだろう。
// デプスがうまく使えるようになれば距離フォグとかできるし早く実装したいわね
// フレームバッファのデプス部分を「レンダーバッファ、無し、テクスチャ」みたいな感じで選べるようにしたい。
// そうしたら...
// 内容が分からないので相当テストが要るわね。

// clearはRenderbufferにも適用されるよ...じゃなきゃあそこの修正が意味をなさないでしょう。
// 多分、framebufferのbindでtexture, renderbuffer, 双方が自動的にbindされる仕組みなのよね。
// ああなるほど...framebufferってそういうことか...まさに、「枠組み」なんだわ。まさに、フレーム。フレームバッファなんだわ。
// depthの内容わけわからんからテストしないと駄目じゃな。
// pointSpriteの動きとかで可視化できるといいんだけどな。

// ごめんなさい間違えた。これで...いいんだ！？
// つまりデプスと色用意したら後はそれをフレームバッファに関連付ける際にバインドはもうしなくていいんだ、すげぇな！

// クリアするパートやめた。これもpavelさん真似したんだけど、まあ、要らないかな...って思ったので。
// infoどうするかって話。
// info:{depth:{},color:{},stencil:{}}
// それぞれレンダーバッファとテクスチャの2つの選択肢がある。選ばない方法もある。そういう話。
// もしくはcolorInfo = {}, depthInfo = {}, stencilInfo = {} でも良さそう？かぶらない。
// attachTypeのデフォルトをそれぞれ"renderbuffer", "texture", "none"（ステンシルは用意しない）にする。
// attachType: "renderbuffer":レンダーバッファとして用意する。"texture":テクスチャとして用意する。"none":用意しない。
// で、こうする。
// info:{w:256, h:256,
//       depth:{attachType:"renderbuffer", info:{}},
//       color:{attachType:"texture", info:{}}, // だからここを配列にしてArray.isArrayで場合分けすればいいんだよな
//       stencil:{attachType:"none", info:{}}};
// これで。そうすれば従来通りinfoは使えるし...いろいろ問題ない、はず...stencilはいつかのために。これも使い道分からんのよ。

// MASKは書き込みされるかどうかを決める
// TESTは書き込んだ値を使うかどうかを決める
// そういうことだと思う。つまりframebuffer作る際にレンダーバッファとしてステンシルを用意すればそれが（ピッキングとかで）
// 使えるようになるんだと思いますよ。いつかね...

// で、おそろしいことにこうするとですね...
// textureFormat → format
// 全部「texture」が不要になるんですねぇ！！（ひぇ...）
// あとvalidate関数がgl要らないのでgl使ってたから消しておいたよ
// おそらくもともとはgl定数にする処理だったんだけどそれだといろいろとめんどくさいということでやめたんだろう。

// あと返り値ですけど、Renderbufferですけど、要らんよね。
// で、今までフレームバッファからなんか取り出すときってテクスチャが一枚だったけど、
// これからは複数だったり、デプスも...とかだったりするから、名前で管理して指定できるようにしないとねぇ。
// そうですね
// てか複数...それでいける、のか？

// Array.isArrayで配列かどうか調べられるからそれでチェックして
// 名前は0,1,2の通し番号で、もしくは具体的に名付け...られる方がいいかな...
// 名前はテクスチャだけでいいです、使うのはテクスチャ。
// 配列化できるのも色だけ。drawBuffersで入れる。可能なのは色だけ！です。
// 配列化できるのは色だけ！！（重要）ということはtextureは関係なくて、色ということが重要なのね。
// Renderbufferも対象外だし。「色」で、「テクスチャ」。はい。了解！！
// あと名前で管理すれば完璧だわね。

// wとhは全部同じでいいよ、ていうか同じでしょう。レジストフレームバッファでコピーすればいい。
// あとtextureはnameを忘れずに指定。これで、いける！
// validationでwとhをコピーしてもいいけど冗長になるからなぁ。回避！

// ダブルフレームバッファについて、それぞれinfoを用意するように仕様変更します。{read:{}, write:{}}って感じで。

// {read:{color:{info:{name:"t", type:"float", filter:"linear"}}},
//  write:{color:{info:{name:"t", type:"float", filter:"linear"}}}}
//  って感じになるわね。nameは何でもいいけど同じじゃないとswapの際に問題が発生するわね。
// setFBOtexture2Dもほぼコピペだから修正必須なのよね。
// というのもこっちでfboを扱わないので。
// validationでdepthは自動的にRenderbufferになるしstencilはnoneになるし
// attachTypeも指定が無ければ勝手に用意される。
// wとhも勝手に上から引き継がれる。何もしなくていい。
// いやあれ、ダブルの場合、assignが使えないから、それぞれ用意しようかと。手間だけど汎用性考えたらメリットしかないので。


//
// 何でもない
// サンプルでbindFramebufferしてるのでbindTextureしてないからおかしいなって思って。
// 予測だけど
// ああいう管理の仕方ならbindTextureは不要ということなのかもしれない
// 今現在の理解ではshaderごとにsamplerIndexを0ベースにして異なるようにすればいいって感じになってるんだけど
// それでいくとあそこは両方とも0になっちゃうんだよ
// 当たり前だよなひとつしかテクスチャ使ってないんだから
// MRTのサンプル！
// なのにあれ、1と2って分けてる。しかも0ってやると画像が出る。板ポリ芸だからな。
// んー...

// 関係ないけどデプスを放り込むの、(z/w + 1)/2 で用意に0～1にできるのな...それはそうだけどさ、だったらさ、
// デプステクスチャ、要らねーじゃん！！（要らねー...）
// WEBGL1のMRTのコード、チャンネルわけの仕方興味深い。真似したいかも。
// そしてこっちもbindTextureは使ってませんね...

// 現在の予想：
// shaderごとに0ベースでindexを付けるならbindTextureを使う。
// それをしないなら全体で同じテクスチャごとに違うindexを使う。と。
// 個人的には、いちいちbindTexture使うことによって通し番号を意識したコード書かなくてよくなるならそっちの方がいいな。
// だってめんどくさい！！！！
