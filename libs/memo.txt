// やり直し！

// どうでもいいけど：https://creating-homepage.com/archives/5006
// まあそういうことらしいです。何だよスペルチェックって、おせっかいうざ...
// まあそういうことで、これで赤い点線が消えました。めでたしめでたし！まあでもAtom使いやすいので好きです！

// バックヤード更新ログ

// 行列って要するに特定のライティング用のシェーダ使うときのカメラ操作とか
// オブジェクトに回転や平行移動をさせたい場合の簡易オプションみたいな位置づけだから
// それ専用のモジュール用意したらいいわね。どうするかな～そのままパクってもいいんだけど...

// というわけで一通りやったよ～疲れた
// てか視錐台見えないっての。何かしらの方法で可視化しないと厳しいわね。
// いつかね。
// テストするにあたり、パイプラインを...ていうかシェーダーを用意しないと。まあそれは
// グローバルで自前で用意するんだけど。
// だって備え付けても仕方ないでしょいじってなんぼなんだから。中身見えてないと色々めんどくさいし。

// カリングについても突っ込まないといけないんだよなぁ...仕方ないんだけど。あれ苦手。でもやらねばね。

// 20220927
// 一応動いたわ...寝るわ...
// Painter側のsizeとtypeは意図した挙動しないということで廃止
// Figureサイドでsizeを2とか3とか指定したうえでcountで割って...って感じで。よろしくで。
// Figureのtypeが今んとこgl.FLOAT固定だけどそのうち色々使う機会が来る...かもしれない。
// 動的更新は今んとこ実行する方法...まあそのうち用意するつもり。Float32の配列を渡してそれ使って...
// グローバルで...とかいう感じで。
// 行列も含めて検証することが山積み。大変だ～。
// webgl2表記でシェーダー書いたりとか。色々ね。

// 手始めに「createShader」と「shader」、これを移してしまう。
// _glでアクセスできないので...（意外だった）まあ仕方ないわね。setUniformもおいおい移していくけど...（未定）

// setUniform、中でuseProgramしてるのか...分けたいんだよな～
// ていうかこの方法でshader作っちゃうとsetUniformが付与されないわけね。まずいわな。

// キャッシュデータのは多分、同じ内容を毎フレームsetUniformするのが無駄が多いんだと思う。でもなぁ...
// テクスチャとか考えるとそれ別に要らないんじゃ...って思ってしまう（いいけど）
// あとこれで網羅したわけじゃないってのはちょっと気になるかも。

// 中でしか使わない関数(private)は_で始めた方がいいと思う。ちょっと修正が必要かも。

// background(~~~)だっけ
// 単色で塗りつぶすのとか欲しいかも

// 20220927
// clearをunbindに改称（clearは別の意味で使いたいので）
// こっちでしか使わない関数に_を付ける（エクスポートしない関数）

// 20220928
// webgl2ではtexImage2Dでの指定の仕方について、typeがgl.FLOATの場合、ちょっとややこしいようで...
// 具体的には「https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D」のInternalFormatのとこに
// リンクが：「https://registry.khronos.org/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE」
// 張ってあってこの組み合わせじゃないといけない。つまりgl.RGBAーgl.RGBAの場合UNSIGNED_BYTE(0～255)を含む3通りで
// gl.FLOATは対象外！
// webgl1のようにやりたかったら下から2番目の「gl.RGBA32Fーgl.RGBAーgl.FLOAT」にしないといけないのだ。
// ...適宜修正しないとね...

// gl.RGBA32F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.FLOAT
// gl.RGBA --- gl.RGBA --- gl.UNSIGNED_BYTE
// 気になるのは...
// gl.R32F --- gl.RED --- gl.FLOAT fbmのマルチパス計算とかできたら面白そう
// gl.RGB32F --- gl.RGB --- gl.FLOAT  ランダムベクトルの格納とかで使えそう


// それ以前に
// https://stackoverflow.com/questions/69016956/webgl2-incomplete-framebuffer
// RGBA32Fは書き込み不可能？？「https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf#page=143&zoom=100,168,666」
// renderableではない、ということ。つまり書き込めるテクスチャとして使えないと...で、調べたらtexStorage2Dというのが
// でてきました。こっちを使え...？というかwebgl2においてそもそもtexImage2Dが非推奨なんだそうです。
// 参考：https://ics.media/web3d-maniacs/webgl2_texture2darray/
// でもpavelさんの流体のは普通にtexImage2Dで取得してたし、書き込んでたし。つじつま合わないんですよね...

// pavelさんこれ使ってた：
// https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float
// 拡張機能です。gl.getExtension('EXT_color_buffer_float');
// これで使えるようになるとのこと。はぁ...なるほどね...これでcolor-renderableになるわけだ...
// webgl2だから拡張無しでOKかと思ったらそういうわけにはいかないわけだ。

// gl定数の辞書は...リスト作っておいて文字列でアクセスできるようにしましょうね...汎用性考えるとね。
// 辞書作らないとキリがないので。
// 勝手に数字書き換えられても困るのでマジックナンバーは使わない方向で

// usage誤解してたわ：https://developer.mozilla.org/ja/docs/Web/API/WebGLRenderingContext/bufferData
// となると頻繁に更新するならSTREAM_DRAWがいいわけだ...そしてwebgl2なので書き込めないようにできるということ。
// でもめんどくさいのでとりあえず...
// readとcopyは書き込み不可能ということですね。readの場合はメソッドで取り出せるようです。
// copyはそれすらできない、TransformFeedbackでGPU内部の処理で変更することは可能みたい。だからこれを指定すると。
// readはあれ、readPixelsを使うってことなんだろうね。使い方...

// カメラについてなんだけどさ...
// vec3とかクォータニオンとか用意して整理するのはどうよ。で、カメラの3本をグローバルのベクトルにして...
// とかしたら面白そう。よくわかんないけど。vec3はクォータニオンに含ませることができる。そして回転量はクォータニオンで
// あらわせる、のも知ってるし、演算も知ってる。ただ使い道とか細かい部分について理解が足りないというか。それで二の足踏んでる感じ
// なんだけど、他の用途（線形補間によるアニメーション）もあるし、苦手意識をなくしたいのよね。

// 20220930
// Timer実装したいかな。とりあえず最低限、スタートとゴールだけ...
// あとあれ
// 名前で始点を決めて、終点で名前を呼び出して、それに60掛けて1000で割った値を出すとか。いわゆる「fpsタイマー」みたいな
// 使い方ができるといいね。ていうか要らないか。単純に差を取るだけでいいや。setとgetでいいや。便利！
// hsv2rgbもだけど、他のプログラムでも使える関数充実させたいわね。

// 今日考えたこと
// トランスフォームフィードバックってバーテックスシェーダだけでいいのでは...？
// ただジオメトリシェーダがないからな...（片手落ち）。その関係で必須なのかもしれない、まだ触ってないからわからん。
// p5.Textureの中身が知りたい。あそこをブラックボックスにしておくのは気持ち悪いからな。頻繁にお世話になってるし。
// save関数でpixelDensityに左右されてしまう問題がいい加減うざいので何とかしたい。そもそもsaveって何やってるの？？
// _glで生成してるRenderNodeだけど_gl使ってなくない？？？まあでもp5.Texture由来のテクスチャを使おうってなったら
// _glも使う羽目になるのかな...極力使いたくないので複雑だわね。
// 雲はいいよ。そのうちUnityかなんかで作る方法探すから。他にやること山ほどあるでしょ。
// さしあたりvbaかなぁ...でも後回しでもいいかなぁ。


// 勉強もかねててつのりさんのリアルタイム~~~をやるのもありかな
// あ、fbmだけどマルチパスでフレームバッファで計算したら負荷が軽くなるかもしれないって思いついた
// あとあれビットシフトランダムやってみたいね。

// 20221002
// 今見たけど「_gl」使ってないですね...一切。ということはglだけでいいということ...
// テクスチャですよね。これを_glを使わないで生成できるようにしましょう。で、登録して呼び出せるようにする。
// マルチテクスチャの実験もする。これで完全に_glと切り離せる。...ということは。。。
// まあ、何とかしましょう。

// _glをglに。_gl使ってないので。廃止。

// 20221003
// precision宣言ですが、バーテックスシェーダは無条件でhighpなので不要とのこと。
// fragについてはノイズなど一部の高い精度が求められる計算の場合にhighpにしないとスマホの方でおかしな挙動になる
// 可能性があるとのことです。ただ富士山に雪降らせるやつはlightFragでhighpしたらおかしくなったんですよ...
// だからさじ加減が求められるとのことです。はい。了解！GPGPU計算とかもhighpのが良さそう。
// ただレイマはそれでも重いんですよね...レンダリングにはかろうじて成功するんですけど、重いです。
// ディファード？で、たとえば法線とか色とか複数のフレームバッファにMRTで書きだして、
// それ使って描画すると速い、可能性がある、とのことです...もしくは深度とか。んー...

// そうよねレイマのライティングは...あーでもあれ、計算？のとこだけhighpが求められる、とかかな...わかんない！

// 20221003
// 地味に更新。辞書にr32fとr16fとredを追加しました。これでR32Fフォーマットのテクスチャが使えるようになりました。
// それはいいけどdrawingBufferWidthとHeight取得する関数とテクスチャ作る関数早く実装してちょ！（はいはい）
// 作りました（getDrawingBufferSizeです。。。まんまです。）
// で、textureはそのうち何とかしますね...copyのvertとfragどうしようね。

// 20221005
// enable, disable, cullFaceあたりでinvalidな名前指定の際にエラーが発生するように仕様変更。
// 問題なく素通りしちゃってたので...困るねこういうの。困るほんとに。

// 重要な変更。法線計算の関数が時計回り前提になってました（p5jsがBACKでデフォルトのポリゴンを描画してて、
// それに倣う形でやってたので）。なので逆にしました。これで反時計回りの頂点指定で法線がきちんと計算されます。
// 今んとこあんまポリゴン系手を出してないので。早めに気付けてよかったです...

// MRT難しくなさそう：https://wgld.org/d/webgl2/w011.html そのうちやってみる！

// 20221005
// 重要な仕様変更：clearなんですが、DEPTH_BUFFERをクリアする、ようにしました。
// えーとね。観察力不足。
// clearDepthの既定値は1です。なので全部1になるわけですね。

// そういえばframebufferのdepth要らない場合は用意しないようにしようとかあったっけ...まあいいや。
// そのうちh_doxasさんのサンプルやるようになったらいろいろ出てくるでしょう...色々ね。

// 20221006
// jsDocですか。なるほど...https://ics.media/entry/6789/
// ライブラリ大きくなってきたしなんか注釈あると便利かもね。

// CameraExをちょっといじってレイマーチングなどに役立つ情報取得の関数を追加

// 20221006
// いろいろおかしい...orthoが機能してない、まともに。
// あとy軸を上方向にしたいのです。テストコード書くよ。
// orthoの行列が転置になってたバグを修正しました。ついでにleft,right,bottom,topのデフォルト値設定。
// それから注釈も。さてと。
// upside down.
// これにより、頂点のインデックスの振り方も逆になります。ひえ。。一旦作りかけのメッシュ関数を排除。あれも、
// きちんと作りたいんだけど今ちょっと暇がないのです。
// y軸上にした関係で法線の計算関数の順番も元に戻すことになりました。なんじゃい...
// そうなんですよね。反時計回りでかつy軸反転だから(-1)^2=1の理屈で元に戻っちゃったんです。なんだかな...

// 正規化デバイスと同じ理屈で頂点を並べていくので板ポリ芸関連は影響ないです、というか射影行列使ってないんだから
// 影響あるわけがない。あったら事件だわ。

// まあy軸逆にしただけなんで、何がどうってことも無いけど。ただね。
// たとえばz軸手前x軸右っていうレイマのテンプレ考えたときにy軸が下向いてたら「はぁ？？」ってなるやん。そういうこと。

// 20221008
// カメラ仕様変更案
// eyeとか個別にいじれるように。あとxだけとかyだけとかでいじれるように。
// で、行列を計算する部分を別に呼び出す感じに。んでperseかortho化に応じて射影行列が計算される仕様...とか。
// farとnearをMAX_DISTとかに当てはめるのも楽しそう。レイマーチング、orthoでもいいと思うから。ねぇ？
// orthoのレイマーチング普通にありだと思うんだけど何であんま見掛けないんだろ...

// typo（setPersepective → setPerspective）

// カメラがcenterの方向を向いてくれない...どうして...
// 本家で確認した。カメラおかしい！！！おかしい！おかしいな...centerちゃんと0,0,0になってるのに...
// どうもcenterが一緒に移動しちゃってるみたいなのよ。というか機能してない？？？

// ...本家の方がカメラの設定してからtransformしてたからそれに倣ったら解消した、
// そもそもきちんと計算したら明らかだったわ。馬鹿ですね...
// 加えて行列のメソッドとしてtranslateやrotateX, rotateYを実装してtransformの方はそこからいただいたメソッドで
// 変換するように修正しました。おつかれ！！

// ...eyeの取得を行列からやってたんですが、あそこeyeの座標値じゃねぇよ！！！間違えた！ので、直しました。

// カメラ移動メソッド2つ追加します
// 一つ目...えーと。upとtopを使って縦方向に移動する感じのメソッド。

// upって更新する必要あるんだろうか。うーん...マウス移動であちこちできるようにしたいなと。
// 周回はいいとして...
// up更新しても特に問題ないよね。更新しちゃうかー。
// それかsphereCameraっていうクラスを用意するといいかもしれない。角度の範囲を制限する。
// それか、upベクトルが更新されないことを使って...視点から中心に向かうベクトルがupとの内積、が-1に近づくのを防ぐなど。
// -0.999より小さくなるようなら動かさない、みたいな。そういう意味でもupは動かさない方が良さげ。
// 周回は簡単、topとsideでちょこっと計算するだけ。ズームも簡単。
// upベクトルと視点から中心へのベクトルの内積の絶対値が0.999を越えない、でよさそうね。
// upを動かさないことでそこら辺がうまく働く、っていうのはいいかもしれないね。本家の方も計算後にupはいじってないっぽい。

// zoomは近づく。マイナスで離れる。slideは対象を見据えつつ横移動。ariseはカメラが上下に移動する感じで。
// ただしcenterはいじらないので対象との距離は変化するわね。
// テストはまた今度

// それとは別に今日考えたこと。魚眼レンズ的効果。
// レイマーチングならそれっぽくごまかせるけどラスタライズの場合直線で補間されるので無駄。
// 考えたのは球面への射影
// eye位置から半球面を想像し
// それを縦に切る大円でアスペクト比とかと相性いいのを選んで
// ピクセルからスタートして球面の方に真っ直ぐ進む、んで視点に向かう、その時の線とキャンバスの交点で、
// 色を採取。だからcenterから外に向かうほど膨張する感じ...
// これをレンダリング結果に用いるだけ。

// 20221009
// というわけでfoldRotate計画頓挫です
// これでよかった。影とか色々やりたいし。ディファードレンダリングも中途半端だからMRT使って完成させたい。
// あんなのにこだわってたら何にもできない。
// ノイズとかそういうのを参考にしよう。多面体はもうええわ。鏡映しか勝たんし、ポリゴンしか勝たん。ポリゴン無敵。ポリゴン最強。
// レイマは鏡合わせ一択。rotateなんぞ知るか。ばーか！
// それはさておき

// カメラについて。ariseだけど、角度でいいと思う。で、やり方としては、外積。topベクトルとupの正規化の外積とsideを使って
// 作った三重積がたとえば0.001より小さくなるようなら動かせない、みたいにするといいと思う。その方がいいだろー
// 以上
// orbit見たらupベクトルを固定するポンコツ仕様だった、まあ参考にできるとこだけ参考にするわ。ほんとp5.jsって（（
// upベクトル揺らしたりとかするの楽しいのに。でもまあorbitでやることじゃないな。まあいいや。さてと。
// そうでなくて任意のupベクトルに対してやりたいって話よ。

// ごめんなさいp5jsの悪口みたいになっちゃった。あーあ。

// とりあえずカメラのテストします。

// なんか知らないけどnearとfarが死んでる...？？？

// 背景のせいでした...depth_testをoffにしてからonにする。これでOK!
// そのうちあれもリメイクしたいね...

// 2022/10/10
// カメラテストOKだけどまだまだです。これからローリングとか、デフォルトUPベクトルをいじる操作をしたいのと、
// そのうえでさっきみたいな動作をして大丈夫かどうかのテストをね...大変だね...

// それからorthoのテストと、あとVec3実装したからそれ使って書き換えるのをやらねば...ていうか
// 法線取得のところもVec3で書き換えたいのだ...

// それ終わったらさっさとH3済ませてバンプとかそっち行こう

// カメラ何を実装するにも...あとマウスでいじるならタッチとそれぞれ同じ挙動にしたいのと
// いい加減一通り設定するのめんどくさいからテンプレート作りましょうか。ライティング。デフォルトメッシュ。やること盛りだくさん。わぁ...
// upX,upY,upZはupベクトルとは別の概念で、これが基準となってカメラの上昇の限界が決まるわけ。
// そこら辺上手く実装してもいいんだけどどうしようかね（ゼロ割を回避したい）。ちょっと思いつかない。通り過ぎても大丈夫なのは確認済み。
// ていうか通り過ぎたら逆になる？のか...んー。まああれ、upをちょっとずらして...っていう？
// だからずらすときに、...内積を取って、ゼロになるようなら足す前のベクトルとupベクトルから適切なベクトルを計算して
// 視点はそこにとどまるようにすればいい。そういうやり方もある。

// 実験で分かると思うけど通り過ぎてるのよ、これいいんだけど、限界前で止まる方が、たとえば姿勢制御とか書く場合にはいいかも。
// よろしくね！

// upをさぁ、名前変えるのと、定義時に正規化...やっぱベクトルで書くべき？
// 頭の向きという意味でheadとかいいと思う。axisでもよさそう。基本軸。axisは上を決めるベクトルで...
// ていうかこれがupか。あ、そうか。えーと...どっちもupにふさわしいからな...
// もういっそカメラの方はlocX,locY,locZで...sideと...side廃止？

// つまり画面の上方向という意味でのupと体の軸を決めるupとが競合しちゃってて、という状況
// あとtopってやってるとこ意味的にはfrontの方がいいかも。そうか。で、あっちをtopにすればいいんだ、
// 中心を中心に視点を回転させるときの限界を決めるという意味でもtopがふさわしいわね。

// 結局、「upX,upY,upZのベクトル」→「top」, 今の「top」→「front」で丸く収まりそう。upは保留。画面の上方向という意味で妥当。それでいこう。
// 改名はいいとして、fovやaspectどうしようね。その...保持する意味あるかなって。あるいは、persモード、orthoモード、frustumモード
// それぞれにパラメータ...んー。んー...要らないかなって。定義するとき必要なだけでviewとは別の概念だし。
// つまり、パース行列を定義する際に使われる数値としての扱いでいいかな、と。でもそうなると...いや、問題ない。
// となると今あそこ、ていうかさ。nearとfarってあれ0.1と10で固定じゃん。つまり射影行列は固定で動かさないじゃん。だからそういう風にしても
// 問題ないし、レイマでfovとaspect放り込むのにしても定数使えばいいだけ、カメラから取得する必要ないだろ。

// だからfovとかaspectを保持するのはやめて、定義するようにしましょう。もしくは！！
// これも提案なんだけど。モードオブジェクト。これを用意する。mode={pers:{},ortho:{},frustum:{}}
// んで、それぞれいじれるように。で、モード切替で射影行列が切り替わるように。取得：getProjData("pers")で{fov:~~,aspect:~~}
// setProjMode("pers")とかで再計算される的な...デフォルトはそれぞれ指定に合わせて...
// とかやればいいんだよ！それでいこう。

// モード変数も保持。mode.type = "pers", "ortho", "frustum"
// たとえばzoomはこのあとあの、fovをね...0 < fov < PIの範囲で変化させるんだけど。その方がいいから。で、それはpersの話だから
// persのときしか反応しないようにしたいわけ。frustumはfov関係ないし。
// そんで視点を中心に近づけるのはdollyっていうんだって、だからzoomとdollyという形で分けたい。
// zoomは視点も中心も動かさないでfovだけ動かすんよね。だから若干挙動が違う、近づくのはdollyのin/outにしたい。
// つまりzoomはpersの話だから分ける。orthoは？単純にnear/farをいじればいい（比率だけど）。
// frustumもnear/far...これ使うとあれ、VRChatのカメラみたいなの作れそうで期待してる。

// 2022/10/10
// カメラ仕様変更案まとめ

// 今のeyeXとかcenterXとか、ああいうのをVec3で管理する。upX,upY,upZであらわされるベクトルはtopに改名。
// 今現在のtopは手前という意味でfrontに改名。side,up,frontのローカル軸ベクトルもVec3で管理。
// 射影の概念をビューの概念と切り離す。ビューの仕事はグローバル→ビュー、射影の仕事はビュー→正規化デバイスで役割が異なる。

// ちょっと待って
// そうか...カメラにtransformを名前で登録する...TransformExのクラスを名前で登録して使い回せるように...
// んで一定の場合はいちいちたとえば法線の、nMatrix的な、あれ同じなのに毎フレーム計算してて無駄...モデルとビューの掛け算も
// 毎フレーム計算するのでなければ無駄だわね...静的/動的は分かりやすく分ける！事前に用意するにしてもその方が分かりやすい。
// データを取り出してuniformに登録するプロセスも分かりやすくなる。記述しやすくなる。それで...まあ、そのうち...

// で、射影のモードを、用意。以上。this.proj = {mode:"pers", pers:{~~~}, ortho:{~~~}, frustum:{~~~}}
// this.tf = {tf0:~~~, tf1:~~~, tf2:~~~} this.eye, center, top, side, up, front すべてVec3

// zoomはpersの場合はfovを増減させる...基準が無いのでそうするしかない。nearんとこの矩形をいじる、でもよいのだけどね。
// それでもいいかもな...んー。near*tan(fov/2)になんか足してnearで割ってatanして2倍。
// fovの増減でいいです。残り二つの場合は矩形の重心を中心として拡大する。拡大率...1より大きい値を設定して掛け算。
// もしくは割り算。ていうかね。具体的な数字だとそれを縦横どっちに適用すればいいか分からんでしょ。
// って思ったけどだったらどっちもそれでいいか。どっちもそれでいいか...

// persはそれとは別にfovを具体的に指定できるので問題ないしorthoとfrustumも具体的に指定できるから問題ないねぇ。
// slideとariseはビューの話なので変更なし。nearとfarを倍率で決めるのも変更なし、です。
// ariseはベクトル三重積を用いてtopベクトルを飛び越えないようにする処理が必要です。

// メソッド追加：panは中心を左右にずらす。distanceは変化しない模様。tiltは中心を上下にずらす。これもdistanceが変化しないようですね...
// さらにもともとzoomだったものはdollyとします。これは視点を中心に近づける処理。そういう名前だったのですね...
// また視点と中心の位置関係を保ったまま同時に動かすmoveも定義。
// さらに中心だけ動かすlookAtも移植します。

// 今見たら本家はtopいじってませんね。いじってませんね...
// panとtiltはtopをいじらない（要注意）
// つまりslideとariseの逆バージョンという扱い。まあいいか、それで。で、じゃあtiltは限界を超えないように注意しないとだわね。
// 今見たらtiltはそこら辺の処理サボってますね...ふざけてるな～～～

// upベクトルいじれないとジェットコースターのぐるんぐるんとか表現できないから不便なのでそのうち用意するとして
// 今はいいや

// メッシュについてもメモ。メッシュ。最終的には複数放り込んでくっつけたりできるようにする。個別に用意して。
// UVとか個別に設定したいし。

// グローバルのx,y,zに対してビューと射影組み合わせてスクリーン座標出すやつ欲しいな～とか思ったり。

// lineで線引いたり出来るようになるのはだいぶ先だわね
