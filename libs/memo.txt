// やり直し！

// どうでもいいけど：https://creating-homepage.com/archives/5006
// まあそういうことらしいです。何だよスペルチェックって、おせっかいうざ...
// まあそういうことで、これで赤い点線が消えました。めでたしめでたし！まあでもAtom使いやすいので好きです！

// バックヤード更新ログ

// 行列って要するに特定のライティング用のシェーダ使うときのカメラ操作とか
// オブジェクトに回転や平行移動をさせたい場合の簡易オプションみたいな位置づけだから
// それ専用のモジュール用意したらいいわね。どうするかな～そのままパクってもいいんだけど...

// というわけで一通りやったよ～疲れた
// てか視錐台見えないっての。何かしらの方法で可視化しないと厳しいわね。
// いつかね。
// テストするにあたり、パイプラインを...ていうかシェーダーを用意しないと。まあそれは
// グローバルで自前で用意するんだけど。
// だって備え付けても仕方ないでしょいじってなんぼなんだから。中身見えてないと色々めんどくさいし。

// カリングについても突っ込まないといけないんだよなぁ...仕方ないんだけど。あれ苦手。でもやらねばね。

// 20220927
// 一応動いたわ...寝るわ...
// Painter側のsizeとtypeは意図した挙動しないということで廃止
// Figureサイドでsizeを2とか3とか指定したうえでcountで割って...って感じで。よろしくで。
// Figureのtypeが今んとこgl.FLOAT固定だけどそのうち色々使う機会が来る...かもしれない。
// 動的更新は今んとこ実行する方法...まあそのうち用意するつもり。Float32の配列を渡してそれ使って...
// グローバルで...とかいう感じで。
// 行列も含めて検証することが山積み。大変だ～。
// webgl2表記でシェーダー書いたりとか。色々ね。

// 手始めに「createShader」と「shader」、これを移してしまう。
// _glでアクセスできないので...（意外だった）まあ仕方ないわね。setUniformもおいおい移していくけど...（未定）

// setUniform、中でuseProgramしてるのか...分けたいんだよな～
// ていうかこの方法でshader作っちゃうとsetUniformが付与されないわけね。まずいわな。

// キャッシュデータのは多分、同じ内容を毎フレームsetUniformするのが無駄が多いんだと思う。でもなぁ...
// テクスチャとか考えるとそれ別に要らないんじゃ...って思ってしまう（いいけど）
// あとこれで網羅したわけじゃないってのはちょっと気になるかも。

// 中でしか使わない関数(private)は_で始めた方がいいと思う。ちょっと修正が必要かも。

// background(~~~)だっけ
// 単色で塗りつぶすのとか欲しいかも

// 20220927
// clearをunbindに改称（clearは別の意味で使いたいので）
// こっちでしか使わない関数に_を付ける（エクスポートしない関数）

// 20220928
// webgl2ではtexImage2Dでの指定の仕方について、typeがgl.FLOATの場合、ちょっとややこしいようで...
// 具体的には「https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D」のInternalFormatのとこに
// リンクが：「https://registry.khronos.org/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE」
// 張ってあってこの組み合わせじゃないといけない。つまりgl.RGBAーgl.RGBAの場合UNSIGNED_BYTE(0～255)を含む3通りで
// gl.FLOATは対象外！
// webgl1のようにやりたかったら下から2番目の「gl.RGBA32Fーgl.RGBAーgl.FLOAT」にしないといけないのだ。
// ...適宜修正しないとね...

// gl.RGBA32F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.FLOAT
// gl.RGBA16F --- gl.RGBA --- gl.HALF_FLOAT
// gl.RGBA --- gl.RGBA --- gl.UNSIGNED_BYTE
// gl.R32F --- gl.RED --- gl.FLOAT
// gl.RGB32F --- gl.RGB --- gl.FLOAT

// それ以前に
// https://stackoverflow.com/questions/69016956/webgl2-incomplete-framebuffer
// RGBA32Fは書き込み不可能？？「https://registry.khronos.org/OpenGL/specs/es/3.0/es_spec_3.0.pdf#page=143&zoom=100,168,666」
// renderableではない、ということ。つまり書き込めるテクスチャとして使えないと...で、調べたらtexStorage2Dというのが
// でてきました。こっちを使え...？というかwebgl2においてそもそもtexImage2Dが非推奨なんだそうです。
// 参考：https://ics.media/web3d-maniacs/webgl2_texture2darray/
// でもpavelさんの流体のは普通にtexImage2Dで取得してたし、書き込んでたし。つじつま合わないんですよね...

// pavelさんこれ使ってた：
// https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float
// 拡張機能です。gl.getExtension('EXT_color_buffer_float');
// これで使えるようになるとのこと。はぁ...なるほどね...これでcolor-renderableになるわけだ...
// webgl2だから拡張無しでOKかと思ったらそういうわけにはいかないわけだ。

// gl定数の辞書は...リスト作っておいて文字列でアクセスできるようにしましょうね...汎用性考えるとね。
// 辞書作らないとキリがないので。
// 勝手に数字書き換えられても困るのでマジックナンバーは使わない方向で

// usage誤解してたわ：https://developer.mozilla.org/ja/docs/Web/API/WebGLRenderingContext/bufferData
// となると頻繁に更新するならSTREAM_DRAWがいいわけだ...そしてwebgl2なので書き込めないようにできるということ。
// でもめんどくさいのでとりあえず...
// readとcopyは書き込み不可能ということですね。readの場合はメソッドで取り出せるようです。
// copyはそれすらできない、TransformFeedbackでGPU内部の処理で変更することは可能みたい。だからこれを指定すると。
// readはあれ、readPixelsを使うってことなんだろうね。使い方...

// カメラについてなんだけどさ...
// vec3とかクォータニオンとか用意して整理するのはどうよ。で、カメラの3本をグローバルのベクトルにして...
// とかしたら面白そう。よくわかんないけど。vec3はクォータニオンに含ませることができる。そして回転量はクォータニオンで
// あらわせる、のも知ってるし、演算も知ってる。ただ使い道とか細かい部分について理解が足りないというか。それで二の足踏んでる感じ
// なんだけど、他の用途（線形補間によるアニメーション）もあるし、苦手意識をなくしたいのよね。

// 20220930
// Timer実装したいかな。とりあえず最低限、スタートとゴールだけ...
// あとあれ
// 名前で始点を決めて、終点で名前を呼び出して、それに60掛けて1000で割った値を出すとか。いわゆる「fpsタイマー」みたいな
// 使い方ができるといいね。ていうか要らないか。単純に差を取るだけでいいや。setとgetでいいや。便利！
// hsv2rgbもだけど、他のプログラムでも使える関数充実させたいわね。

// 今日考えたこと
// トランスフォームフィードバックってバーテックスシェーダだけでいいのでは...？
// ただジオメトリシェーダがないからな...（片手落ち）。その関係で必須なのかもしれない、まだ触ってないからわからん。
// p5.Textureの中身が知りたい。あそこをブラックボックスにしておくのは気持ち悪いからな。頻繁にお世話になってるし。
// save関数でpixelDensityに左右されてしまう問題がいい加減うざいので何とかしたい。そもそもsaveって何やってるの？？
// _glで生成してるRenderNodeだけど_gl使ってなくない？？？まあでもp5.Texture由来のテクスチャを使おうってなったら
// _glも使う羽目になるのかな...極力使いたくないので複雑だわね。
// 雲はいいよ。そのうちUnityかなんかで作る方法探すから。他にやること山ほどあるでしょ。
// さしあたりvbaかなぁ...でも後回しでもいいかなぁ。


// 勉強もかねててつのりさんのリアルタイム~~~をやるのもありかな
// あ、fbmだけどマルチパスでフレームバッファで計算したら負荷が軽くなるかもしれないって思いついた
// あとあれビットシフトランダムやってみたいね。

// 20221002
// 今見たけど「_gl」使ってないですね...一切。ということはglだけでいいということ...
// テクスチャですよね。これを_glを使わないで生成できるようにしましょう。で、登録して呼び出せるようにする。
// マルチテクスチャの実験もする。これで完全に_glと切り離せる。...ということは。。。
// まあ、何とかしましょう。

// _glをglに。_gl使ってないので。廃止。

// 20221003
// precision宣言ですが、バーテックスシェーダは無条件でhighpなので不要とのこと。
// fragについてはノイズなど一部の高い精度が求められる計算の場合にhighpにしないとスマホの方でおかしな挙動になる
// 可能性があるとのことです。ただ富士山に雪降らせるやつはlightFragでhighpしたらおかしくなったんですよ...
// だからさじ加減が求められるとのことです。はい。了解！GPGPU計算とかもhighpのが良さそう。
// ただレイマはそれでも重いんですよね...レンダリングにはかろうじて成功するんですけど、重いです。
// ディファード？で、たとえば法線とか色とか複数のフレームバッファにMRTで書きだして、
// それ使って描画すると速い、可能性がある、とのことです...もしくは深度とか。んー...

// そうよねレイマのライティングは...あーでもあれ、計算？のとこだけhighpが求められる、とかかな...わかんない！

// 20221003
// 地味に更新。辞書にr32fとr16fとredを追加しました。これでR32Fフォーマットのテクスチャが使えるようになりました。
// それはいいけどdrawingBufferWidthとHeight取得する関数とテクスチャ作る関数早く実装してちょ！（はいはい）
// 作りました（getDrawingBufferSizeです。。。まんまです。）
// で、textureはそのうち何とかしますね...copyのvertとfragどうしようね。

// 20221005
// enable, disable, cullFaceあたりでinvalidな名前指定の際にエラーが発生するように仕様変更。
// 問題なく素通りしちゃってたので...困るねこういうの。困るほんとに。

// 重要な変更。法線計算の関数が時計回り前提になってました（p5jsがBACKでデフォルトのポリゴンを描画してて、
// それに倣う形でやってたので）。なので逆にしました。これで反時計回りの頂点指定で法線がきちんと計算されます。
// 今んとこあんまポリゴン系手を出してないので。早めに気付けてよかったです...

// MRT難しくなさそう：https://wgld.org/d/webgl2/w011.html そのうちやってみる！

// 20221005
// 重要な仕様変更：clearなんですが、DEPTH_BUFFERをクリアする、ようにしました。
// えーとね。観察力不足。
// clearDepthの既定値は1です。なので全部1になるわけですね。

// そういえばframebufferのdepth要らない場合は用意しないようにしようとかあったっけ...まあいいや。
// そのうちh_doxasさんのサンプルやるようになったらいろいろ出てくるでしょう...色々ね。

// 20221006
// jsDocですか。なるほど...https://ics.media/entry/6789/
// ライブラリ大きくなってきたしなんか注釈あると便利かもね。

// CameraExをちょっといじってレイマーチングなどに役立つ情報取得の関数を追加

// 20221006
// いろいろおかしい...orthoが機能してない、まともに。
// あとy軸を上方向にしたいのです。テストコード書くよ。
// orthoの行列が転置になってたバグを修正しました。ついでにleft,right,bottom,topのデフォルト値設定。
// それから注釈も。さてと。
// upside down.
// これにより、頂点のインデックスの振り方も逆になります。ひえ。。一旦作りかけのメッシュ関数を排除。あれも、
// きちんと作りたいんだけど今ちょっと暇がないのです。
// y軸上にした関係で法線の計算関数の順番も元に戻すことになりました。なんじゃい...
// そうなんですよね。反時計回りでかつy軸反転だから(-1)^2=1の理屈で元に戻っちゃったんです。なんだかな...

// 正規化デバイスと同じ理屈で頂点を並べていくので板ポリ芸関連は影響ないです、というか射影行列使ってないんだから
// 影響あるわけがない。あったら事件だわ。

// まあy軸逆にしただけなんで、何がどうってことも無いけど。ただね。
// たとえばz軸手前x軸右っていうレイマのテンプレ考えたときにy軸が下向いてたら「はぁ？？」ってなるやん。そういうこと。

// 20221008
// カメラ仕様変更案
// eyeとか個別にいじれるように。あとxだけとかyだけとかでいじれるように。
// で、行列を計算する部分を別に呼び出す感じに。んでperseかortho化に応じて射影行列が計算される仕様...とか。
// farとnearをMAX_DISTとかに当てはめるのも楽しそう。レイマーチング、orthoでもいいと思うから。ねぇ？
// orthoのレイマーチング普通にありだと思うんだけど何であんま見掛けないんだろ...

// typo（setPersepective → setPerspective）

// カメラがcenterの方向を向いてくれない...どうして...
// 本家で確認した。カメラおかしい！！！おかしい！おかしいな...centerちゃんと0,0,0になってるのに...
// どうもcenterが一緒に移動しちゃってるみたいなのよ。というか機能してない？？？

// ...本家の方がカメラの設定してからtransformしてたからそれに倣ったら解消した、
// そもそもきちんと計算したら明らかだったわ。馬鹿ですね...
// 加えて行列のメソッドとしてtranslateやrotateX, rotateYを実装してtransformの方はそこからいただいたメソッドで
// 変換するように修正しました。おつかれ！！

// ...eyeの取得を行列からやってたんですが、あそこeyeの座標値じゃねぇよ！！！間違えた！ので、直しました。

// カメラ移動メソッド2つ追加します
// 一つ目...えーと。upとtopを使って縦方向に移動する感じのメソッド。

// upって更新する必要あるんだろうか。うーん...マウス移動であちこちできるようにしたいなと。
// 周回はいいとして...
// up更新しても特に問題ないよね。更新しちゃうかー。
// それかsphereCameraっていうクラスを用意するといいかもしれない。角度の範囲を制限する。
// それか、upベクトルが更新されないことを使って...視点から中心に向かうベクトルがupとの内積、が-1に近づくのを防ぐなど。
// -0.999より小さくなるようなら動かさない、みたいな。そういう意味でもupは動かさない方が良さげ。
// 周回は簡単、topとsideでちょこっと計算するだけ。ズームも簡単。
// upベクトルと視点から中心へのベクトルの内積の絶対値が0.999を越えない、でよさそうね。
// upを動かさないことでそこら辺がうまく働く、っていうのはいいかもしれないね。本家の方も計算後にupはいじってないっぽい。

// zoomは近づく。マイナスで離れる。slideは対象を見据えつつ横移動。ariseはカメラが上下に移動する感じで。
// ただしcenterはいじらないので対象との距離は変化するわね。
// テストはまた今度

// それとは別に今日考えたこと。魚眼レンズ的効果。
// レイマーチングならそれっぽくごまかせるけどラスタライズの場合直線で補間されるので無駄。
// 考えたのは球面への射影
// eye位置から半球面を想像し
// それを縦に切る大円でアスペクト比とかと相性いいのを選んで
// ピクセルからスタートして球面の方に真っ直ぐ進む、んで視点に向かう、その時の線とキャンバスの交点で、
// 色を採取。だからcenterから外に向かうほど膨張する感じ...
// これをレンダリング結果に用いるだけ。

// 20221009
// というわけでfoldRotate計画頓挫です
// これでよかった。影とか色々やりたいし。ディファードレンダリングも中途半端だからMRT使って完成させたい。
// あんなのにこだわってたら何にもできない。
// ノイズとかそういうのを参考にしよう。多面体はもうええわ。鏡映しか勝たんし、ポリゴンしか勝たん。ポリゴン無敵。ポリゴン最強。
// レイマは鏡合わせ一択。rotateなんぞ知るか。ばーか！
// それはさておき

// カメラについて。ariseだけど、角度でいいと思う。で、やり方としては、外積。topベクトルとupの正規化の外積とsideを使って
// 作った三重積がたとえば0.001より小さくなるようなら動かせない、みたいにするといいと思う。その方がいいだろー
// 以上
// orbit見たらupベクトルを固定するポンコツ仕様だった、まあ参考にできるとこだけ参考にするわ。ほんとp5.jsって（（
// upベクトル揺らしたりとかするの楽しいのに。でもまあorbitでやることじゃないな。まあいいや。さてと。
// そうでなくて任意のupベクトルに対してやりたいって話よ。

// ごめんなさいp5jsの悪口みたいになっちゃった。あーあ。

// とりあえずカメラのテストします。

// なんか知らないけどnearとfarが死んでる...？？？

// 背景のせいでした...depth_testをoffにしてからonにする。これでOK!
// そのうちあれもリメイクしたいね...

// 2022/10/10
// カメラテストOKだけどまだまだです。これからローリングとか、デフォルトUPベクトルをいじる操作をしたいのと、
// そのうえでさっきみたいな動作をして大丈夫かどうかのテストをね...大変だね...

// それからorthoのテストと、あとVec3実装したからそれ使って書き換えるのをやらねば...ていうか
// 法線取得のところもVec3で書き換えたいのだ...

// それ終わったらさっさとH3済ませてバンプとかそっち行こう

// カメラ何を実装するにも...あとマウスでいじるならタッチとそれぞれ同じ挙動にしたいのと
// いい加減一通り設定するのめんどくさいからテンプレート作りましょうか。ライティング。デフォルトメッシュ。やること盛りだくさん。わぁ...
// upX,upY,upZはupベクトルとは別の概念で、これが基準となってカメラの上昇の限界が決まるわけ。
// そこら辺上手く実装してもいいんだけどどうしようかね（ゼロ割を回避したい）。ちょっと思いつかない。通り過ぎても大丈夫なのは確認済み。
// ていうか通り過ぎたら逆になる？のか...んー。まああれ、upをちょっとずらして...っていう？
// だからずらすときに、...内積を取って、ゼロになるようなら足す前のベクトルとupベクトルから適切なベクトルを計算して
// 視点はそこにとどまるようにすればいい。そういうやり方もある。

// 実験で分かると思うけど通り過ぎてるのよ、これいいんだけど、限界前で止まる方が、たとえば姿勢制御とか書く場合にはいいかも。
// よろしくね！

// upをさぁ、名前変えるのと、定義時に正規化...やっぱベクトルで書くべき？
// 頭の向きという意味でheadとかいいと思う。axisでもよさそう。基本軸。axisは上を決めるベクトルで...
// ていうかこれがupか。あ、そうか。えーと...どっちもupにふさわしいからな...
// もういっそカメラの方はlocX,locY,locZで...sideと...side廃止？

// つまり画面の上方向という意味でのupと体の軸を決めるupとが競合しちゃってて、という状況
// あとtopってやってるとこ意味的にはfrontの方がいいかも。そうか。で、あっちをtopにすればいいんだ、
// 中心を中心に視点を回転させるときの限界を決めるという意味でもtopがふさわしいわね。

// 結局、「upX,upY,upZのベクトル」→「top」, 今の「top」→「front」で丸く収まりそう。upは保留。画面の上方向という意味で妥当。それでいこう。
// 改名はいいとして、fovやaspectどうしようね。その...保持する意味あるかなって。あるいは、persモード、orthoモード、frustumモード
// それぞれにパラメータ...んー。んー...要らないかなって。定義するとき必要なだけでviewとは別の概念だし。
// つまり、パース行列を定義する際に使われる数値としての扱いでいいかな、と。でもそうなると...いや、問題ない。
// となると今あそこ、ていうかさ。nearとfarってあれ0.1と10で固定じゃん。つまり射影行列は固定で動かさないじゃん。だからそういう風にしても
// 問題ないし、レイマでfovとaspect放り込むのにしても定数使えばいいだけ、カメラから取得する必要ないだろ。

// だからfovとかaspectを保持するのはやめて、定義するようにしましょう。もしくは！！
// これも提案なんだけど。モードオブジェクト。これを用意する。mode={pers:{},ortho:{},frustum:{}}
// んで、それぞれいじれるように。で、モード切替で射影行列が切り替わるように。取得：getProjData("pers")で{fov:~~,aspect:~~}
// setProjMode("pers")とかで再計算される的な...デフォルトはそれぞれ指定に合わせて...
// とかやればいいんだよ！それでいこう。

// モード変数も保持。mode.type = "pers", "ortho", "frustum"
// たとえばzoomはこのあとあの、fovをね...0 < fov < PIの範囲で変化させるんだけど。その方がいいから。で、それはpersの話だから
// persのときしか反応しないようにしたいわけ。frustumはfov関係ないし。
// そんで視点を中心に近づけるのはdollyっていうんだって、だからzoomとdollyという形で分けたい。
// zoomは視点も中心も動かさないでfovだけ動かすんよね。だから若干挙動が違う、近づくのはdollyのin/outにしたい。
// つまりzoomはpersの話だから分ける。orthoは？単純にnear/farをいじればいい（比率だけど）。
// frustumもnear/far...これ使うとあれ、VRChatのカメラみたいなの作れそうで期待してる。

// 2022/10/10
// カメラ仕様変更案まとめ

// 今のeyeXとかcenterXとか、ああいうのをVec3で管理する。upX,upY,upZであらわされるベクトルはtopに改名。
// 今現在のtopは手前という意味でfrontに改名。side,up,frontのローカル軸ベクトルもVec3で管理。
// 射影の概念をビューの概念と切り離す。ビューの仕事はグローバル→ビュー、射影の仕事はビュー→正規化デバイスで役割が異なる。

// ちょっと待って
// そうか...カメラにtransformを名前で登録する...TransformExのクラスを名前で登録して使い回せるように...
// んで一定の場合はいちいちたとえば法線の、nMatrix的な、あれ同じなのに毎フレーム計算してて無駄...モデルとビューの掛け算も
// 毎フレーム計算するのでなければ無駄だわね...静的/動的は分かりやすく分ける！事前に用意するにしてもその方が分かりやすい。
// データを取り出してuniformに登録するプロセスも分かりやすくなる。記述しやすくなる。それで...まあ、そのうち...

// で、射影のモードを、用意。以上。this.proj = {mode:"pers", pers:{~~~}, ortho:{~~~}, frustum:{~~~}}
// this.tf = {tf0:~~~, tf1:~~~, tf2:~~~} this.eye, center, top, side, up, front すべてVec3

// zoomはpersの場合はfovを増減させる...基準が無いのでそうするしかない。nearんとこの矩形をいじる、でもよいのだけどね。
// それでもいいかもな...んー。near*tan(fov/2)になんか足してnearで割ってatanして2倍。
// fovの増減でいいです。残り二つの場合は矩形の重心を中心として拡大する。拡大率...1より大きい値を設定して掛け算。
// もしくは割り算。ていうかね。具体的な数字だとそれを縦横どっちに適用すればいいか分からんでしょ。
// って思ったけどだったらどっちもそれでいいか。どっちもそれでいいか...

// persはそれとは別にfovを具体的に指定できるので問題ないしorthoとfrustumも具体的に指定できるから問題ないねぇ。
// slideとariseはビューの話なので変更なし。nearとfarを倍率で決めるのも変更なし、です。
// ariseはベクトル三重積を用いてtopベクトルを飛び越えないようにする処理が必要です。

// メソッド追加：panは中心を左右にずらす。distanceは変化しない模様。tiltは中心を上下にずらす。これもdistanceが変化しないようですね...
// さらにもともとzoomだったものはdollyとします。これは視点を中心に近づける処理。そういう名前だったのですね...
// また視点と中心の位置関係を保ったまま同時に動かすmoveも定義。
// さらに中心だけ動かすlookAtも移植します。

// 今見たら本家はtopいじってませんね。いじってませんね...
// panとtiltはtopをいじらない（要注意）
// つまりslideとariseの逆バージョンという扱い。まあいいか、それで。で、じゃあtiltは限界を超えないように注意しないとだわね。
// 今見たらtiltはそこら辺の処理サボってますね...ふざけてるな～～～

// upベクトルいじれないとジェットコースターのぐるんぐるんとか表現できないから不便なのでそのうち用意するとして
// 今はいいや

// メッシュについてもメモ。メッシュ。最終的には複数放り込んでくっつけたりできるようにする。個別に用意して。
// UVとか個別に設定したいし。

// グローバルのx,y,zに対してビューと射影組み合わせてスクリーン座標出すやつ欲しいな～とか思ったり。

// lineで線引いたり出来るようになるのはだいぶ先だわね

// CameraEx2をとりあえず構築、テスト待ち。
// 2022/10/11
// defaultが予約語だったので修正。Vec3のおかげですっきりかけました、デバッグ次第だけどな...
// って
// 今更バグなんか怖くねぇんだよなぁ（浮動小数点数バッファのgl_PointSize=1.0で何回ハマったか...）

// Oh!!eyeからcenterを引くつもりが、centerからeyeを引いてたんだね！Oh,My!Oh,My!
// frustumのc8が±逆でInfinityなっててウケる。そりゃ、なるわ。
// とりあえず一通りモード確認した。今日はこのくらいでいいと思う。

// 20221011
// distanceに射影行列が支配されてるのでdistanceを更新するたびに行列の方もいじらないといけないんですが...
// 問題は解決できます。
// Camera2なら簡単。まずdistanceの更新作業の際にそのときのモードの行列を更新する。
// 次にモード変更時にもそのときの距離とモードに応じて行列を更新。これでOK!

// 好きなところにCone配置するとか...そのうち出来るようになるよ...軸とか作りたい。

// frustumのleft,right,bottom,topはdistanceとの比率で指定しないと分かりづらいわね。nearがそうなってる以上、
// これらもそうしないと普通に指定しづらいだろう。

// nearとfarは別メソッドでいじる、そんでclipとか名付けてfrustumの場合はそれに応じて矩形の値を変化させて
// 見た目が変化しないようにすると。

// 関係ないけど_triangulate, あれライブラリの移植ですね。計算もはっきり言って魔窟、似たような実装作るのは無理、つまり、
// あれに関しては_glから有難く頂戴するしかない、そうなると文字メッシュとか分割とかもそうせざるを得ない。諦めて。
// どうしてもというなら元ネタ使う。libtessで調べれば出てくる。ただどう使えばいいかは...どう使うんだろうね...

// もうひとつ。p5.js、webgl部分を叩くのもいいけど、他の部分、知らない機能とかもあるし、あんま馬鹿にすると痛い目見そう。
// 謙虚に。

// 結局、いいものは既にたくさんあるし、それ使いこなせるようになる方が楽で、p5jsで出来ないことは他のツールでできるし、
// p5jsが目的のためにしょぼいことしか出来ないんだったら素直に他のでやればいいわけですから。無意味。そういうことで。
// これ作る努力も結局無意味なんかね。優越感...優越感を味わって心を癒したいだけ...おれはp5jsの駄目な部分を直してやってるんだこいつが
// ポンコツだから、みたいな。叩いてけなして悦に入るのが目的？？そうだったの...？
// 仕事があれで、仕事であれで、自分がクソで、短いコードしか受け入れられなくて、そういうのしか作っちゃ駄目みたいな、コケにされて、
// お前駄目だダメだって、なって。弱い者いじめして。...

// 疲れた

// 結局あれ、頑張ってブルームとかいろいろ、そういうの、でも結局見られるのも反応されるのもつぶプロばっか、
// 違うんだよってなってもなんか、多面体とか、ああいうのも、「誰が作るかが大事～何を作るかじゃなくて～誰が」おれじゃなくて
// そうですか
// TessSky Slice Mt.Fuji snowy ... ... ...
// ねぇ。肥大化した自尊心が
// うぬぼれが
// それで、それで、それで、自分がダメダメで、だめで。はぁ。こういうの作って。それで優越感に浸って、
// もういいです。

// はぁ。だからもうこれは、こういうのはすべて放棄して...

// 20221011
// 仕様変更。モードチェンジ関数は廃止。projの各関数を呼び出すときに自動的に変更
// 仕様変更。frustumモードでnearが変更され矩形の変更が無い場合、見た目が変わらないように矩形を拡縮させる
// 仕様変更。frustumモードで矩形の長さをdistanceに対する比率とする。その方が指定しやすい。
// zoom,spin,arise一応OKなんだけどね。spinで角速度が一定にならない...
// 軸周りの回転実装したらあっさりできた...おつかれ！！

// 20221012
// zoomのfrustumでバグってた。
// モード切替OK

// 球面補間。まずクラス。で、ベクトルを持つ。で、destVectorとcurrentVector.で、
// 移動中は操作できない。で、常に...dest===currentなんだけど、destが変化する、あの、カウンターで。
// 時間制御。updateで足す。足して、一定の値を越えたらそれをチェックしてリセット。
// それと、キャッシュしておいた数値を元に補間、適宜イージング。で、OK.

// 終わる前にメッシュについて簡単に計画だけ立てておく
// 立方体は±1の8つで。スケーリング...

// あの、メッシュ構築時になんか行列をユニフォームで掛けるのであれば、んー...
// たとえば無数に多くのってなった場合uniformは使えず、たとえばidを付与してフレームバッファに落としてそれを参照して変換みたいに
// なるわけですけど（6000個の頂点に対して逐一行列掛けてたら日が暮れてしまう）
// そうでなくてもたとえば1000個の、が40個とか...8000が8つとか...
// だから構築時にtfするのは無しで。で...
// 単純に一律でなんか行列掛けるだけであれば、idを付与したうえでfbに焼いてvsで参照する。

// おわんないよ～

// 確かに一つ一つがたとえ64個くらいだったとしても、それ100とかだったら6400回も行列掛けないとってのはまあ面倒だわね。
// 場合によっては1回とは限らないし...同じものコピーできた方がエコ。というわけで、
// tfについてはそれをフレームバッファに落とす方向で行こう。
// 必要なら3x3,3x3,3x3でcos(t)とsin(t)と1の掛け算の和でさらにuTimeの何倍かをtとするとかで。
// 28. vec4が7つ。で、2800とか。100個別々に動かしたりできるよ。高速で。
// 軸周りの回転でもいいし何でも。平行...あ、そうか...
// 基本的には回転した後で平行移動、ってのがオーソドックスだと思う。だから、
// 3x3,3x3,3x3,1で回転、さらに3で位置。これで4x8に収まる。？？
// 3x3で3,3,3を1,cos,sinの結合...？？
// 3x3,3x3,3x3,1,3x3,1...面倒...4x12でいいと思う。

// そうすればidごとに、違うメッシュの集まりが、フレームバッファの情報を元に、
// 一定の位置まで移動したうえで、もしくは一定の円かなんかの軌道上で、独自の回転運動をするし、
// それをuniformで指定することも無い。つまりドローコール減らせるわけです。そんな感じで。

// 描画の問題はそれでいいとしてメッシュの構築の問題はそれとは別。
// tfについては...だからね。あの、あれ。そういうの全部、cosとsinが一次式である限り、最初にスケール変換したうえで、適当に回転しても、
// そのあと継続的な回転を施しても、それ結局一次式だから。問題ない。だからデフォルトだけ用意しよう。
// 計算はどうせメソッドでやるでしょ

// そういうわけでキューブは-1～1でいいし球もxyz軸ベースで半径1でいい。円柱も高さ±0.5でいいし円錐も高さ±0.5で...
// 台柱は底面半径1で上面が可変になるように（1より小さい）。

// トーラスも比率だけが重要かな...長半径を1で固定しつつ、短半径を0～1と。後はスケールの問題。
// 平面も±1で。これは±1の方がいい...あ、法線？？法線は...
// 平行移動部分で法線は変化しない。それ以外の場合、まず今回スケールに関してはいじらない。定数。そして
// 直交行列の逆は転置。なので直交行列は逆転置の影響を受けず、スケール変換だけが受ける。それも分けておいて...
// 結局今回のように単純な場合、スケール関連の処理だけ考慮すればいいから、法線は中でいじってしまおう。

// モデルが毎回違う...

// webgl2なので普通にモデルビューを作って（ビューはあるのでそれに然るべくモデルをかませるだけ）逆転置でいいや
// 決まった
// 4x12のフォーマットで、上から順に3x3,3x3,3x3で回転、3x3で平行移動。
// その隣に3,3,3でスケール（スケールも時間的な変化を考慮）、最後の3でスケール、回転、平行移動用のテータファクター,
// 合計4x12です。たとえばこれが2000個であれば4x12x2000で96000ですね。多くない（え？）
// 40x50=2000. 4000個ならば80x50で...
// 平行移動オンリーのバージョンも用意するか...
// まあいいか。何でもできるように...
// 欲張ると何にもできないのでまずはこれをやります。

// 曲線データを用意してその上を走る...とか？無理。トーラスノット？？？

// そういうのはいつかで。いいです。今は無理です。

// トーラスノットと正多面体と星形多面体とあとあとあと...

// 20221012
// 原因発覚しました、Math.asinは-1～1の外にある値に対してはNaNを返すんですが、
// ぎりぎり1を越えてしまい、それでNaNになったようです（ほんとにぎりぎり）
// 応急処置として1を越えたら2から引いて-1を下回ったら-2から引くようにしました
// acosを使って工夫するとか、色んな方法があるんだろうけど。変形してatanとか。でも今はこれで許してね。
// 1を越えちゃうのはどうしようもないな...

// 結論
// モデルはこっちで作るかDLするかして、結合するのだけメソッド化して、それを適切に...

// 20221013
// normalをVSで計算することにしたのでgetNormalMatは廃止。あちこち変えないといけないかも。まあ適宜。

TODO
// TODOリスト（覚え書き）
// vba（バーテックスバッファオブジェクト）
// save関数移植（サイズがおかしくならないような...pavelさんのサイトみたいに）
// texture（自前で用意できるように...canvas情報から）
// h_doxasさんのサイトのあれこれ（鏡面反射とかshadowとか）
// ライティング関連の充実、トランスフォーム関連の整備、カメラ2画面の実験、MRTで色付き高速描画
// 簡単なプリミティブの構築（頂点と法線だけでいいです）
// webgl-water（今年の目標はこのレンダリングの流れでこれを再現してOpenProcessingに載せること。いつになるのか...！）

// 歯車メッシュ重いですね。ディファードなら軽くなるのかなぁ。試してみたいな～みたいな～～～みたいな～～～な！
// そのうちね...

// modelに関しては目途が立ったと思う
// 頂点の付け方については反時計回りに...なる。y軸の向きが逆なら反時計回りになる。exportの際にy,zの指定で問題ない。
// こっちは射影行列いじってy軸正にしてあるから問題なく同じように動かせる。それはいいとして...
// 内部データ取得して複製とか。まあでもこれは...頂点数増えたり複雑になるようならインスタンシング...

// 優先順位的にはMRT優先で。モデルはUVの話は切り離す。どうせモデルでいいし。モデルでないと自由にUVとか決められんし。

// 何していいかわからんのでロードマップ作った。漏れてもいいからとりあえず歩き出そう。でないと、終わらん。
// ロードマップ
// まずテクスチャ何とかする
// モデルからのFigure構築
// 閉曲線からメッシュ作る関数の整備...splitとテキストまでは要らないけど。
// マルチ描画とディファード...デプスが消えなければ重ね掛けが利くはず、そのテストね
// MRTの簡単なテスト。まあやらなきゃ始まらんね
// MRTで色付き高速描画
// MRTとマルチ描画で色付き複数オブジェクト高速描画（ここで歯車に応用、って流れだと思う。そういう意味かと。）
// ライティングの充実（スペキュラーだけでも）
// ライティング関連のテンプレートシェーダ（フォワード、ディファード双方）
// 各種ユニフォームセッティングメソッドの整備
// 後回し
// Vertex Buffer Array
// 3Dテクスチャ、環境マッピング、屈折とか光学迷彩などそこら辺。

// 大量描画のパイプライン作る話はどこへ...まあ、いいか...

// ゆくゆくは3Dテクスチャペイント
// そのロードマップについて簡単に説明しておく
// まず通常の描画と同時にMRTでUV値をキャンバスに格納する
// マウスダウンされたらその座標を中心に256x256くらいの範囲で2Dに描画がなされる
// それとは別にpixelDensityを考慮した点の集合があってそれをUVmapのフレームバッファに落とすことでテクスチャの更新を実行する
// 要するに
// テクスチャそれ自身を作り出すわけではなくて...あーでもそうか。たとえばp5で作るにしても画像読み込むにしても
// うんそういうこと
// まずloadImageで画像読み込むだろ
// んでそれを使ってテクスチャを作ってそれとは別にフレームバッファのテクスチャも作る。
// そのテクスチャに読み込んだテクスチャをコピーしオブジェクトの描画時に呼び出してテクスチャペイントとする
// その内容を画像の方を更新することで変えたいんだけど直接2D画像に手を下すことはできない
// というか3Dモデルの方に手を加えてそれがテクスチャ画像に反映されてっていうのを書きたい
// だから3Dの方にUVを貼り付けて範囲内のUVが存在する点に対してUVのところに色を付与、という形を取りたいわけ。以上。

// じゃあまずテクスチャ
// 悪いけど簡単にしたいので入力はp5のグラフィックオンリーでお願い（update前提）
// だから単純にcanvasで取得した結果をtexImage2Dに渡すだけでできる
// updateもしかるべく。
// って思ったけど普通に...でもいいな...
// p5.Imageの場合：canvas要素を取得。
// p5.Graphicsの場合：elt属性を取得
// ImageDataの場合：そのまんま
// という分け方のようで初期化でやることは4つ。ひとつは各種パラメータの管理、次に種類別のpixelsの取得。
// texImage2Dの実行、WRAPとMINMAGの設定。
// メソッドについてはWRAPとMINMAGの切り替え、あとはupdateかなぁ。updateについては2Dのp5のGraphicsが書き換えられることを
// 想定している。
// とはいえ
// さっきのように3Dテクスチャペイントなどは、最初の段階で元のp5ImageだかGraphicsだかはセットした時点で破棄されたも同然であって。
// textureからsaveを発動させる方法を学ばないと、framebuffer経由で更新したテクスチャの保存ができないよね。
// そもそも保存の仕方が分からんのだが...

// まずテクスチャを保存する（元のサイズで）やり方はpavelさんに従うとして、
// 3種類の指定方法についてはそれを別に、んー、まあ、然るべく。

// saveはいいとして。textureについて...やらなきゃ始まらないんだよな。やるべき。やろう。

// 20221016
// MIPMAP用のパラメータを導入。MIPMAPの指定がある場合それを作成する。
// 使う機会があるか分からないけど...テクスチャペイントとかで使えるかも？

// カメラの2を取り上げてさらにタイマーを更新しました...基本的な使い方は一緒です。
// いつかはやらないといけない。今でしょ！！

// Timer更新。カメラの2もなくしました。結論、仕様変更は、大変...！
// test10以降を番号をずらして一旦保留にしました。それどころではないので。

// UInt8ArrayじゃなくてUint8Arrayでした。ごめんなさい。iは小文字でしたね...

// copyShaderは簡単なんですよね。まずVSでuvを取ってvaryingで渡し、FSでセットしたテクスチャを...
// nullであればスクリーンに、nullでなければセットしたframebufferのtextureに、大きさそのままでコピーする。
// つまり縦横ぴっちりぴったりくっつけ！です。

// Textureについてはmemo_textureさんが頑張ってくれてる
// こっちはこっちで別の事をします。
// 遠い未来の目標として。

// CameraとTFをRenderNodeにぶち込んで名前で管理する。
// グローバルを、やめる。
// Timerまでは入れないけど。

// 20221018

// どうでもいいけどclearとclearColor...clearだけでいいよね。なんか、無駄。
// clearで色指定すればいいだけ。

// 今考えてること。
// cameraとtfを統合したWorldクラスを作る
// cameraやtfを適宜返すようにすれば従来通りのchain表記も可能。

// 有効なtfやcameraを文字列で指定しつつメソッドは踏襲で
// 射影やらモデル、モデルビュー、まとめて放り込む関数が欲しい（名前はもう固定でいいし）
// できるわよね
// ついでにライティングクラス「light」も用意しつつ...
// オブジェクト渡すだけで全部やってくれるとかだと嬉しいんだけど
// 複数の
// 様子を見てから

// copyProgramFBO使えばポストエフェクト系めっちゃ簡単に実装できるわ
// ガウスブラーとかブルームとかsobelもlaplacianも自由自在だわね（モノクロも）
// あと_timerんとこdurationTimeとduration混在してるから直しといて：直したよ～～～

// シャドウマッピングむずい。今は無理。

// ピッキングできたけどめんどくさいな。使わなくていいuniformを切るのがめんどくさすぎる、
// MRT無いと実質無理。それと、setUniformのエラーがうざいからなんか出してくれるようにエラー処理よろしくね。
// https://zenn.dev/yukiota/articles/cb53ea21d7cf3994861a
// とか参考になりそう。

// ていうか簡単なテストであっても割とめんどくさいわね...ライティング周り実装急がなきゃ
// 立方体も毎回コピペするの面倒だな...とはいえ慎重にならないとゴミが増えるだけ。そこきちんと考えないといけない。
// あれ。外来種の再導入みたいなやつ。きちんとしないと問題が発生してご破算になるので。

// p5framebufferさん、UNPACK_FLIP_Y_WEBGLのオプション使ってる（問答無用で）
// まあ前提、ポストエフェクト前提ならそういう選択もアリなんかね。
// 今回こういうことがあってそれもアリかなって。
// まあオプションとしてつけとこう。でも普通に使う分には混乱すると思うからデフォルトはfalseでね。
// んなことよりライティングを...

// UNPACKやめよう。めんどくさい。めんどくさいものは採用しません

// さてライティングを...20221019

// まずdiffuseをoutで書く。resultの代わりにdiffuseとspecularにしてoutで書いて、
// それを内部で更新すればいいよ。
// specularの場合、directionalLightに関してもmodelPositionが要るのよね...
// なのでまあ、まあ使わなければいいんですけどね...

// viewDirectionは-modelPositionの正規化
// specularでしか使わないからカットしたんだっけ

// framebufferの各バッファのサイズを、任意指定できるようにした。違う方がいい場合もあるので。
// setUniformのエラーを受け付けるように改良
// エラーはsetUniformで登録したにもかかわらずその値が内部で全く使用されていない場合に起こる
// つまり仮に利用されていなかったとしても（無駄でしかないが）setUniformで送らなければエラーにはならないということ。

// 配列にする準備が整った。さてと。
// あれに倣って5つまで...まあそんなたくさんあっても仕方ないのよ。

// TODO
// 簡単なMRTのテスト
// ピッキングMRT
// 深度可視化MRT
// ディファードMRT
// テクスチャペイントMRT, ただし平面で。立方体、トーラス、ゆくゆくはモデル、objの解析方法などなどetc
// どんどん知っていこう。
// あとTimerのduration機能で遊びたい。以上。シャドウマッピングはまたいつか。

// 理解不足。Program差し替えても同じvboが使えるっぽいですね。
// attributeが中で使われてなくても問題ないそうです。
// これは何がまずいかというと
/*
this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo.buf);
// attributeLocationを有効にする
this.gl.enableVertexAttribArray(attr.location);
// attributeLocationを通知し登録する
this.gl.vertexAttribPointer(attr.location, vbo.size, vbo.type, false, 0, 0);
*/

// ここの理解が中途半端なんですよね。
// https://qiita.com/emadurandal/items/5966c8374f03d4de3266 （みんな大好きエマさんのわかりやすいattributeに関する記事）
// この記事で...（ていうかこういう厨二っぽいノリ苦手だからこういう記事あんま読めないっていうか普通に要領よく説明して
// ほしいってつい思ってしまうんだけどまあいいや）

// シェーダーのattribute変数は、GPU上のレジスタと対応付けられる ようです。
// programから問い合わせるが...programとは関係ない？programから問い合わせるのに？？
// gl.enableVertexAttribArrayはgl.useProgramとは何の関係もない ようです。
// locationはprogramから問い合わせるのに？？

// （いくら調べてもスマホだけエラーになる理由が分かりそうにないけれど...まあいいか）

// gl.useProgramでのシェーダープログラムの切り替えにかかわらず、
// gl.enableVertexAttribArrayによるレジスタの有効化、gl.disableVertexAttribArrayによるレジスタの無効化は、
// 効果が持続する のだそうです。ほうほう。uniformと同じで0詰めみたいになってるんかな

// ここuniformみたいに整理して書けるようにしないとねぇ...uniformは完全にprogramのみのお話だから分かりやすいんだけど。
// vboは...attributeは...

// WebGLの実装系によっては、シェーダーで実際に使っていないのに有効化されているレジスタ番号があるとワーニングが出るケースもある

// これですかね。それでdisable?

// gl.vertexAttribPointerを呼ぶ前に、gl.bindBufferの呼び出しによってバインド状態になっていたVBOこそが、
// gl.vertexAttribPointerによって指定されたレジスタへアタッチされる、という仕組みになっている

// それで先にbindする必要があるのか～unbindでnullにしたら効果がなくなると。

// 問題の詳細："pick"のpainterは_loadAttributesでaPositionしか入手できなかったんよ。
// スマホだと。それでエラーになったわけ。

// 調べました～
// _loadAttributesでgl.getProgramParameter(pg, gl.ACTIVE_ATTRIBUTES);を実行していますが、
// これの結果がスマホだと、その、pickで、なんですが、lightと異なるんですよ...
// パソコン：lightと一緒で4つ（cubeが持ってるのは2つだけど）
// スマホ：aPositionのひとつだけ。わぁ。
// そういうわけでaNormalでエラーになったわけね。そういうことらしいです。わぁ。。。

// 気を付けないと。ほんとに。要するにactiveの判定の仕方が処理系によって異なるようです。

// gl.getAttribLocationにしても、これシェーダープログラムを指定しますけど、
// 結局のところこのシェーダープログラムのこのattribute変数に割り当てられているレジスタ番号はいくつ？ っていう、
// レジスタ番号を問い合わせるためのただの便利機能（実際は異なる）

// 今回のことを知らない人がこのgl.getAttribLocationの関数仕様を見ると、
// シェーダープログラムの切り替えで頂点アトリビュート（レジスタ）の状態も切り替わるって思っちゃっても
// 不思議はないですよ。実際は違うわけですが

// VAOってuniformのあれと同じなのかな...

// なんかあんま参考になってないけど、いいか。

// 登場するすべてのattributeに出現順に0詰めで番号を付与してそれを使うようにすれば
// もはやprogramは不要で
// つまりどっかのProgramには登場するから登場した際にそのlocationをattributeに記録させれば
// もはや問い合わせは不要で...
// 今回みたいなことが起こるんだったらgetProgramParameterベースであの処理を書いた方が良さそうね
// ただそこに現れるのに存在しないattributeについてはどうする？programサイドはlocationを提供してくれているが
// エラーになるね。
// 結局のところ、あそこに「どっちもundefinedでない場合だけ有効化しなさい」って書けば済む話なのでは？

// if(vbo === undefined || attr === undefined){ continue; } // これを追加する
// これで行けると思う。てかこれがあれば何も起きなかった。それはそれで怖いわね。

// おそらく既知情報なんですけどuniformのlocationはオブジェクトなんですね。ほんとうにprogramごと。
// 対してattributeのlocationはレジスタ番号。整数。しかもさっきの話だとprogram関係なくて、出現するattributeごとに用意されるっぽいね。
// 違うaPositionが出てくる場合は...調査中。
// 今回は同じvboで違うprogramってケースだから。違う図形とか扱う場合はまた別の問題が生じるのかも？さっきの話また読んで勉強しないと。

// 提案
// frustum廃止して"rect"ってモード作るわ。
// "rect"は基本的には一緒なんだけど、上下左右のrectの位置をcenterを通り視線に垂直な平面内で
// 実際の長さで指定する。
// 多分p5jsもこれを想定していたんじゃないかと推測してる。だってあれがデフォルトっておかしいでしょ。
// まあいいや。そんな感じ。
// nearで、しかもnearと同じ中心までの距離との比率で定義するってめんどくさすぎるでしょ。
// orthoやperspectiveと比べて絶望的に分かりづらい。なんでnearなのよ。
// 中心のところであれば大体のスケールを把握しやすいから便利だと思うのよね。

// カメラとTFを整理する前にやってしまいたい...

// readPixelsとgetAttrInfoを実装します。
// readPixelsについて、h_doxasさんのこの記事は参考になります：https://wgld.org/d/webgl/w086.html
// 制約：colorで、textureで、0番で、bindされている。これらの条件を満たすtextureから、
// pixel値指定で（0～1ではない）入手できます。
// 1x1でピンポイント指定したいならば0.5を足すべき、ですかね。linearであれ、んー。そこはまあ...
// たとえばlinearなら挙動も変わるのかもしれないけどわかんないな。wrapはどうか？さぁ...

// ----------------- //

// 20221021
// TODO

// 1. mipmapについて。
// まずmipmapですがMINだけです。ちゃんと！！ちゃんと読んで！このポンコツ！！
// なので個別に設定できるようにします（mag,min,sWrap, tWrap）。この際全部。
// 同じでいいならmagとsWrapだけ指定すればいい。というわけでfilterとwrapは廃止するのであちこち変えないといけないのだ...
// （当然だけどこういうのは静止画用の話で動画の話じゃないよ、それだったらbloomみたく毎フレーム用意するか、
// ...まあいいや。で、まあ静止画、それも縮小する際に不具合が生じる場合限定ですね。）

// 2. copyPainterの拡張について。
// 次にcopyPainterですがrectを複数用意する形式で書きたいです。で、あの、alignを設けて、まあデフォは左上指定にして、
// alignで左下指定に書き換えてシェーダーに渡してそっちで頂点の位置いじってってやる。UVもいじって貼り付ける。OK.
// 統一しよかな...Array.isArrayがfalseなら[{}]ってすればいいだけの話。
// そうなるとviewsとかするんじゃなくてinfoの中にviewって書けばいいかな。
// しかしこれ、全体に対する...んー。そうなるとviewって不要だね...
// だってviewで範囲決めてその中で...っておかしいでしょ。全体で、その中で、ってしないとだよね。そうしようね。双子葉植物。
// それとは別にviewも。viewとは別に、viewsの代わりに...忘れちゃった、viewsでいいや。
// 各infoにviewを持たせるということですね。alignで指定方法をいじれるといいですね。
// あとfboがdoubleの場合は一番最後にswap, これもデフォルトfalse, doubleならデフォルトtrue, にしようか。
// たとえばポストエフェクトだとか、あるいは乗算やオーバーレイをベースに掛けていく場合なんかに最初になんか置くということを
// 考えると大事かなと思うので。そういうの、doubleの方が都合がいいでしょう。あるいは将来的にポイントスプライトをバラまくとか。
// そういうことにも使えると思う（GPGPUデータ格納など）。
// アイデア無いけど（でもまあswapは大事）

// 3. spotLightについて。
// 次にspotLightも実装しよう。
// これでpunctual系は揃うけれど...どうしよ、メビボさん(mebiusBoxさん)のコード真似しようかな...迷うわ～
// 最終的には物理ベース行きたいし。でもまあ一応真似する方向で。
// 次に、あのコードをディファード用に書き換えるのはもう簡単。ポイントはmodelPositionを引数にして
// グローバルじゃなくても困らないようにすること。それくらいです。
// 整理するのに構造体を使うことも検討...mebiusBoxさんがそれでやってたので。権威には従うべき。

// あとねぇ（まだ何か...？）、カメラのヘルパー欲しい。線でいいから。カメラセットするとヘルパー描画してくれるの。
// frustumの線だけ描画する。何処が描画されるのか一目瞭然。
// 加えて深度値もくっきりするのでそこら辺のデバッグにも最適！
// 座標軸のヘルパーもほしいかも。長さを入力する...

// depthのテクスチャか。どうなるんだろう。テクスチャの中身か...気になるねぇ。
// せっかく4画面あるんだから別視点とかやりたいねぇ。
// あとpointLight, directionalLight, spotLightそれぞれについて影！ああ、やることが多い...！

// foxParseはいい経験になった。でも「失敗」という経験というほかないですね。
// overlayなんてshaderなら一瞬なのに。
// foxParseみたいな失敗作どうでもいいからマニュアルやチュートリアル作るんならp5wgexのそれを作りたいわね。

// 20221022
// magFilter, minFilter, sWrap, tWrapに改名。冗長かもしれないけどwebglに敬意を表して省略はしません。まあ、問題を防ぐためにも。
// エラーが出たらその都度直せばいい。いちいち気にするのは疲れるので。

// copyPainterはまず4枚のrectを用意してそれらの頂点はいつもの-1とか1で正規化デバイスでそのまま使う、で、
// おやすみなさい

// Quad作った。countを考慮して4,8,12,16で描画する。view指定はinfoにぶちこむ。で、flipするかどうかもinfoにぶちこむ。
// 配列でない場合は[]でくくる。で、viewはalignに応じて左下ベースで修正する。で、fbでdoubleの場合はswapをtrueにする。
// swapのデフォルトはfalse.（当たり前） alignのデフォルトは"left_top"とする。flipのデフォルトはtexならtrueでfbならfalseで
// flipはUVを送るときにvertexShaderで行う。以上。

// 20221023
// varyingでintを使うときはflat修飾子を使おうね
// 定義の仕方が変わってる...x,y,z,wで指定するの？？

// 冷静に考えたらその方が分かりやすいから、いいや。

// setUniformがBOOL配列に対応してなかった（おい）
// そりゃうまくいかないわけだわ。本家のp5.jsが対応してなかったからつい真似してしまったのよね。はぁ。
// なるほど整数属性使えないのか...まあ補間できないしね...当然か...

// とりあえず最大8個まで。
// 制限を取っ払う方法はあるけど今はこれでいい
// いつまで経ってもやりたいことができないので前に進むよ。

// デフォルトペインターで軸とかカメラのヘルパーとかね、やりたいし。

// 問題解決しました
// 問題の詳細：
// MRTで4つのtextureに描き込んだものを一枚で描画する際に
// Feedback loop formed between Framebuffer and active Texture.が
// 2回目以降のループで発生しました
// 原因は0番のtextureUnitがからっぽになっていなかったこと
// test19.jsでは何故か発生しなかったが...なぜこっちだけ発生したのかは本当に謎でしかない
// まあいいけどね
// 仕様変更詳細：
// _loadUniformsでsamplerIndexの最大値を取得
// PainterのメソッドであるunbindをunbindTextureに改名（テクスチャのunbindはPainterの仕事）
// これはたとえて言うならパレットを洗うようなもの
// マルチテクスチャの場合全部洗えてなかった
// なのでsamplerIndexの上限に関するデータを用いて
// 全部からっぽにするように指示しました
// shaderを切り替える際には常に呼び出していますが...（Figureの切り替えでは特に問題ない）
// unbindが問題になった初のケースなので割と混乱しました。理解が足りないのです...
// ていうか複数のtextureUnit使ってるのにunbindあれでいいのかってのはまあ思ってはいたので

// すっきりしてよかったです。

// これで前に進めるぞ！！！！！！！！

// 適宜getParameter使っていくかな...デバッグ厳しくなってきたし。

// 割と時間かかりそうだなって思ったけど最終的にPainterのunbindいじるだけで済んだ。
// これが理想的なんよ
// あっちもこっちも変えないとってなったら全部破綻して最悪全部作り直しになってしまう
// MRTに手を出すってのはそういうことなのね
// 冷静に見極めて冷静に対処しないと
// 足をすくわれる

// 20221023
// GLSLって%使えないのか...ところがどっこい。uintで2べきの数字限定ならbitShiftで%に相当することができるのよね。
// たとえば%32であれば32が2^5だから(n<<26)>>26ってやれば桁が溢れて下から6番目以降がすべて消えてそのあと戻すことで32で割った余りが出る。
// さらにずらせば、途中の連続する数桁の取り出し、なんてことも出来るね。応用が広そう。やったぁ。
// って思ったけどflatで渡したら挙動死んだ。無理。

// bit演算の結果を可視化する工夫が必要なんだろう。今はおいておこう。

// もう次行こうよ。

// 簡易GUI欲しいね。Lightの調整とかしやすくなるので。
// デプスをtextureに落としてそれを利用するのテストやってみたい
// あと非同期、now loadingのあとdrawループが始まるやつ、promiseで書いてみたい（そういうの管理するとか）

// 簡易GUIのイメージ
// まずfolder構成とかその、えー、...
// 複雑なことさせようってなったらまた大変だろうけどそうではないならもっと楽にできるはず。
// const gui = guiManager;
// guiManager = (function(){~~~~~~})(); こんな感じ。
// たとえば0～60で1刻みの"c"っていう値があったならguiからgui.get("c")で出るとか。あるいは
// gui.set("c",value)で逆に"c"にvalueをセットできるとか。色だったらgui.get("mainColor")って感じでgetして組み込めるの。
// そういうのほしいから作ってっていう話。めんどくさいでしょテストするのとか。本当に、めんどくさい。
// folderの切り替えもできるように！
// てかlil.guiでやりたい。datは更新終わっちゃったから。
// まずイメージとしては...名前で作る。いくつも作れるんだって。で、オブジェクトが生成されるので...
// gui.create("myController");で生成、使用宣言はgui.use("myController");でこれ以降myControllerで紐付けられた
// objectがノードになる。で、登録はこっちでデフォルト等を決めて...する。folderについて...

// lil.gui:https://lil-gui.georgealways.com/#

// registのtargetを特定のfolderに切り替える。framebufferみたいに。そうすればregistも普通にできるね。
// folderごとに違う名前にして名前空間みたいにしてもいいかもしれないけど今のところ全部違う名前...じゃないといけないみたい。
// うん、framebufferのようにregistの対象をfolder切り替えでそのfolderになるようにすればいいやね。
// nullだったら親に追加する。これでいこう。

// 雑談だと思って聞いてね
// copyPainterの変種、色々作れそうで戦慄してる。
// だってcopyPainterそのまま使うだけでも、中身差し替えて位置いじるだけでスライドとか容易に作れてしまうぞ...
// それにblendを実装するってなったら高速でオーバーレイも乗算も自由自在、ブラーも高速、グローも、...
// はいはい

// あーーーーーーーーーーーーーーーーーーーーーーーーーーーー！！！！！！！

// つぶプロの高速化禁止！！！
// 前に進めない！！！！！！
// 禁止！！！時間の無駄！！！ああああ！！！
// 禁止！

// きつい。
// 貴重な休み...貴重な休みが...！！！！

// 20221025
// リンクエラーになる。同じuniformをvsとfsで使うと。それは駄目だよ、ということ。
// なのでどっちでもviewMatrixを使いたいなら
// 方法1:違う名前にする
// 方法2:同じ名前にして片方から引き渡す（ただし頂点ごとの値をvaryingで渡す形になるので補間の影響...全部同じだから問題ないか）
// uniformは一律なので引き渡しで補間されることはないです。

// 20221025
// 馬鹿か...またやらかした。View行列は4x4でしょう？なぜ3x3だと錯覚していた...！？
// カメラのメソッド追加。ついでにmat4に長さ4の配列に対するあれ、用意して。4つくらい。

// あ～そうか、あの行列「それ」を想定してない...仕方ねぇな。とりあえず全部空にして。
// dataInputとdataUpdate以外なくす。

// 雑談  ------------フルネセレやめようの話-------------
// フルネセレは避けた方がいいね。topベクトルの取り方について。
// 要するに重力と反対方向に取ればいいのよ。だから平面ベースで縦方向に波打つように動かす昨日の螺旋みたいなのだったら
// 普通に(0,0,1)でいいし、あるいは球面やトーラスの上を這うような場合はそこにおける法線ベクトルをtopにすればいいわけ。
// それで普通にtangと外積取る感じでいけると思う。円柱に巻き付くような曲線ならその法線でいいし、みたいな。そんな感じが
// 良いのではないかと思います。カメラワークの参考になれば。

// そういうこと。sliceで取得するとまあ、そういうことが起きる。
// ベクトルくらいですから、ベクトルだけね...
// Vec3だけFloat32Arrayが使えるように仕様変更しました。

// ついでに
// Timerに新機能「getDeltaDiscrete」を新たに追加しました。これはintervalごとに増加する整数を返すものです。
// 要するにframeCountですね。ただ間隔は自由に決められる上、スタートも勝手に決めることができます。
// 離散値が欲しい場合もあるでしょうから用意しました。必要なものを、必要な時に。それが健全な仕様変更というものです。
// でないと混乱する。

// 20221026
// copyShaderで今背景が透明、というか何もおかない場所が透明になってるのだけど、
// 最終結果のaが0のところをどうするかっていうね
// たとえば2種類の色を用意して簡単なグラデーションとか
// あってもいいかもしれないなと。思っただけ。そのくらいにとどめる。混乱の原因になるので。

// ディファードも気になるしもうほぼ完成してる感じだけどとりあえずlil周りを用意してライティング楽にするかな...
// lilを自作ライブラリ化するかどうかは慎重に見極める...要らないかもしれないしな。慣れればいいだけのことで。
// 苦手意識があってさ。払拭したいのよね。

// lilなんかよりマウス操作に関するあれこれを何とかしたい
// たとえばあれにしてもタッチなら同時に複数動かしたりできるわけで。今のところスマホでしか動かないしそれも不満。
// ディファードで負荷を軽くしつつタッチ周りを整えて複数動かせるように、pavelさんのコードで勉強する必要がある。
// てか流体もやってないし。まあ遠い未来の話...その前にCubemap勉強して...んー。webglwater？高負荷だから気が進まないけど。

// 20221026 仕様変更情報。
// getViewFromNDCだけど実際のz座標でやってるんだけど、というかViewの。Viewのz座標って実際の値でやるよりかはCenterとの
// distanceの方が自然じゃない？って話になった、nearとfarもそれで決めているし。でもああいう用途なら実距離の方が自然。
// なのでcenterBased=false/trueを使ってこれがtrueの場合はdistanceとの比率で指定できるようにする（ratioだけ...これをdistanceに
// 掛け算、後は同じ）。

// 仕様変更終わり。そのうちTessSkyもどきを作るときに役立つかも？
// 今見たらtouchとmouseはpavelさんの流体書いたときのがそのまま使えそう。ほんとはTessSkyこれ使って書き直したかった。ただ
// あまりにもあまりにも不評でモチベが砕け散ってしまってできなかった。そのうち劣化コピー作ると思う。その時は
// これをメソッド化したものが使われるといいね。
// たとえば2画面にして別の画面でメッシュが生成される様子を見れるとかしたら面白いかもしれない

// タッチ周りは簡単なコード書いてテストした方がいいわね
// 2Dで複数の正方形をdrag/dropするコードを書いてテストしよう。

// copyPainterでUVのoffset合った方がいいかなって思ったり。
// シームレステクスチャのUVスクロールとかに対応してるといいかもしれないって思った。

// 3D迷路、2画面でやるとか...（？？）

// 3Dお絵描き、ビュー空間であの方法でお絵描きしつつその結果をあのメソッドでメッシュ化してそのうえで頂点登録する際に
// 行列使ってグローバルに変換する形になると思う。あっちはどうやってるのか知らないけど。で、プレビュー表示は2Dグラフィックス使う感じ
// かなぁ。いつになるやら。
// オリジナルのTessSkyはメッシュの頂点登録時にいじってないですね。いじってません。描画の際にTFいじってる。
// まあそれでもいいけどね...んー。んーー...自分的にはアウトかな...って思ってしまう。
// 普通に頂点いじってさ、んでたとえばx軸に平行とかz軸に平行とかそういうの、にすべき？わかんないけど。まあいいや。
// どうせどう作っても

// 仕様変更情報
// 20221026
// CopyPainter. 仕様変更は3つ。
// 1. opacity. 要するに透明度。デフォルトは1とする。掛ける。
// 2. UVscroll. バーテックスにおいて然るべくFlipした後でマイナスする。たとえば0.1マイナスで右下に動く。
// 3. Gradation. 2点指定。指定が無ければいいんだけど。フラグメントでUVの2点を指定して決まった色で（デフォルトは両方0,0,0,0で）
// 片方からもう片方に向かう感じのグラデーションを作ってそれと最終結果でアルファ値で合成する感じ（opacity適用後）

// あと今日思ったのはその、対象と同じViewにおけるz座標ってやったけれど、
// 対象を通りx,y,zのいずれかの軸に垂直な平面内、とかでもいいかなって。
// もしくは対象を通りx,y,z軸に平行な方向に移動するとか。この場合マウス位置というのは厳しいので、
// 対象を通る直線のViewへの投影にマウス位置から垂線をおろしたところ、って感じになると思う。はい。
// あと地味なんだけど、view指定ね、長さ4の配列でも指定できるようにしようね。

// 準備終わったけど...相当テストが要るでしょうね...大変だ。
// とりあえずtest0はokのようです。ここでいろいろ実験するか。

// グラデーションで致命的なエラーが発生してる...UVがおかしいのかな...
// あ、drawElementsにしよう。
// ていうか普通にdrawElementsだろ...何でdrawArraysでやってたんだろ...
// あとdrawElementsの第二引数のcount要らないので排除。

// ああ...貴重な時間が...！！
// 馬鹿じゃん...悔しい....

// swap要らないから消しておいた

// 思い出した。あれだ。flatでint渡すやつ。あれだ。今ならいけるはず。
// そうか...drawElementsじゃなかったからflatで渡したときの挙動が意味不明だったのか...バカすぎる...
// なるほど...ただまあそうね。tint（掛け算）とambient（足し算）用意するか。
// 計算が全部終わってからrgbに掛け算するtintと足し算するambientがあると面白いと思うのよね。
// もっとも...んー。でもまあそのうち、そうね...んー...tintとambientくらいならいいか？

// 直し終わったよ。
// ちょっとショックね。凡ミス。頭の中のイメージをきちんとコードに落とすのって本当に難しいわね。
// 普通に考えれば8つの長方形は別々なんだからインデックスの個数とか考えても
// 明らかにIBOを使って描画するべきなのよね。反省しかないわ。ごめんね。

// 20221027
// まず報告
// flat int で グラデーション、radialも追加で。フラグ0,1,2で管理。それで完成。あとtintとambientも追加で。それでOKです。
// flatでint渡すのできました。
// depthTextureについて。
// Qiitaの記事：https://qiita.com/aa_debdeb/items/128ccb6fa245b6f618b3
// DEPTH_COMPONENT32FはFLOATでいいそうです：https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
// なるほど、これでいいのね。
// あと立方体のメッシュの改良よろしく。Blenderからパクればいいと思う（え）
// でもおそらく:https://github.com/davepagurek/p5.Framebuffer/blob/main/BlurRenderer.js
// こっちが参考になる。おそらくだけど近くが0で一番遠くが1ってのは間違いない。
// depthのクリアのデフォが1だから格納する際の処理は単純に-1～1を0～1に同じ大小関係で入れてるだけ。
// 次の計算：
/*
float depthToZ(float depth) {
  float depthNormalized = 2.0 * depth - 1.0;
  return 2.0 * uNear * uFar / (uFar + uNear - depthNormalized * (uFar - uNear));
}
*/
// 要するに0～1を-1～1に直したうえで、ビュー座標におけるzを出力しているわけ。でもこれ射影変換の行列によって
// 結果が違うよね？Orthoとかだったら別の処理が要ると思うのよね。単純にあれ、クリップミスだと思う。あんまあてにならない的な...
// クリップは大事だなと思わせられたのでした。以上。
// まあでもビュー座標系でのZの値が必要な場合もあるのかな...実際の距離か。あー、被写界深度とかの場合だと実際の距離に変換して
// 比較する必要があるのかもしれない。おいおい勉強していくしかない。とりあえず今はdepthのtextureは0～1. それだけ確認。
// h_doxasさんがうそつくわけないもんね。

// おお...仕様変更ノーミス...！逆に怖い（おい）
// TODO
// タッチとマウスで処理分けるやつを
// それとディファード、それで一応あれは完成。さめがめ...作ってみたいね...
// lilもサンプル作ってみるのと、デプステクスチャの目途が立ったのでやってみる（ほんとに0～1だそうなので）
// それで簡単な影、簡単な反射、とりあえずの目標はそこら辺。立方体のメッシュ改造するの忘れないで。UVも付けて。

// touches使う？...

// グラデーションのところ、やっぱ result.aと1-result.aでブレンドした方が良さそう。テキストが汚くなる。こっちが正解かと思います。
// 難しいね...
// はい。よくできました。で...
// Timerなんですが...

// ---------------- 停止と再開 ---------------- //
// うん。今のままだとquitが出来ないですね...もちろん解消する方法はあって、んー...
// たとえばdurationを使わないのであれば、...
// 個別に？？
// 個別にか。その場合アイドリング時間を記録する必要があるのよね。で、終わったらその分を引く...つまりスタンプから引く。
// 引かないでDeltaを取るとアイドリング時間が加算されてしまうので。そんな感じですかね。なので、それを処理するために、7
// lastStoppedを追加。lastStoppedは停止するとき記録され、再開したらperformance.now()を取得して差を取ってその分を
// Stumpから引く。こうすることで？？
// ちげーよ。逆！足すの！！
// 足すことで引き算の結果がちいさくなるんでしょ。足すの！！え？
// あ、確かに...足すんだわ。10でチェックして30～60でアイドリングして80でデルタを取るとかそういう場合、
// 60のところで10を40に更新しないと正しい値である40にならない。70になってしまう。OK! なんとかするわ。

// pauseとstart. lastPause. これでいこう。
// pauseとreStart実装、重ね掛けも回避、onChangeまでテスト完了。

// copyPainter最後の仕様変更。uvに掛け算を許す。これが無いと片手落ち。
// そして20221029.

// copyPainterをdoubleに適用する際の「常にswap」は取り消し。
// 20221029
// copyPainterちょこっと仕様変更。全体のviewportもいじれた方がいいかなって。でないと常に全画面になってしまう、
// それはちょっと柔軟性が欠けるねって話になった。
// それとuvの掛け算。とりあえずそれで。終わりで。はい。

// 20221030
// ドローコール減らそう
// まずplaneとtorusをまとめる、0,1,2,3,4,5,6.
// 1～6はtorus, 例の方法でメッシュをまとめる。全部デフォルト、z軸に突き刺さるのでOK.
// んで4x7のframebufferで4x1ごとにmodel行列を生成するshaderを作るだろ、modelMatrixBuffer(MMB)を作って読み込ませることで
// modelMatrixの代わりにするのでもうtfは要らないし、vとpとvpしか使わない。
// それとライト増やす際にもうこれただのマスクだからfb増やすだけで増えてく感じで
// ライトの数だけRED32fのフレームバッファを用意する感じ
// それをライティング計算で...んー。後回しでいいか。あのあれ。
// マスク作ってからそれを使って補正、のところをカットしてマスク作ったらもうすぐにcolorに落とす感じにする。というか
// fbのtextureとcolorでくっつけて、ってそのまま出しちゃおう。

// planeはtexture描画でチェック模様、torusは0,1,2のいずれか選べるように、頂点色はあらかじめ用意しておく。
// planeも用意しておく（全部白でいい）、UVはcompositeの際はいっしょくたでOK（どうせ分けるなんて無理）。

// 負荷が重いのが続いたね。
// 軽いのやりたい
// とりあえずあとトーラスノットと大量の四角形で影やったら次行こうかな
// ...
// 方向性間違ってないよね？
// 間違ってる？間違ってるかもね。
// 間違ってるなら修正しないとね。
// コラッタ描きたい

// 言いたいことはわかるけど
// 一度は通らないといけない道を通っただけ
// 複数モデルの結合とかモデル行列の動的更新とかいろいろ道具は手に入ったし
// なにより影作成の手ごたえつかんだのが大きい
// 無駄とかいうな
// まあでも黒歴史が増えただけだわね。そうね。
