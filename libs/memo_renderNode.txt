// 今、_node = new RenderNode(this._renderer.GL);
// ってやってるところをね。
// _node = new RenderNode(800, 640, option)
// ってやるわけ。
// optionのデフォルトで
// ・WEBGLの初期設定
//   --- alpha:true, depth:true, stencil: false, antialias: デフォルトはtrueでいいや
//   --- premultipliedAlpha: false, preserveDrawingBuffer: true 明示的にclearしない限りclearされない。
// ・キャンバスをセットするノードのid（デフォルトはmainタグの0番）
// ・canvasのid名（デフォルトはfoxCanvas_0）で通し番号で管理
// ・canvasのクラス名（デフォルトはfoxCanvasClass）
// depthのlequalはいいと思う。depthも無いと困るでしょう。
// あー、あとあれ。フレームレートと...
// drawの代わりにrequestAnimationFrameを使うのであればテンプレートとしてあれを使わざるを得ないので
// Timerを備え付けてそこにアクセスする形で色々やることになるわけ。fps0とか。
// fpsのデフォは1000/60で。というか1000/fpsだ。
// んでその、まあ、timerへのアクセスもメソッドとして用意するわけで。
// それとは別にTimer個別で利用することも可能ですが。

// あのテンプレに落とす場合drawにいろいろ書くっていう部分をサンドイッチしないといけないわけだけど
// できるっぽいな
// なるほど...

// だからこっちでdrawにいろいろ書いて
// あとはまとめて実行させるだけ...

// setupとdrawを渡して実行させる。それでいける。2Dも同じように書こう。
// 別々でいいと思う...出来ることが違いすぎる

// 以上！

// 2Dは？まんまでいいよとりあえず。

// preloadの移植
// 大雑把に言うとpreloadが終わるまでの間代理キャンバスが表示されるんですよね
// ただそれだと色々矛盾が...

//　やめよ。

// そこまでやる必要ない。preloadでいいじゃん。てわけでこの話はおしまい。
// んーーーーー......


// 表現。要するに自分なりのAPIのWrapperを作ろうって話でした。

// loadするだけならimageのonloadとかそういうのでいいわけなので。
// objectのパースにしてもね...

// PromiseAllっていうのがあって。あれを使う。
// それが終わるまでは画面に...というかbodyに代理キャンバスを描画し続ける。2dで文字で。で。おわったら破棄してsetupしてdrawする感じ。
// ？？

// たとえばsetupとdrawをPromise.allのthenに書けばいい
// そんでregistSetupとregistDrawでそれをやればいいと思う
// 最後にdoneでいける
// 停止もできるね
// Promise.allの引数の配列にたとえばimageをロードしたかったらロードするとかして
// Soundをロード、モデルをロードしたかったらロードするとかする感じですかね...わかんないけど
// loadSoundはどうしようね...まあ何とかなるでしょ。
// 今は考えない
// とにかくimageやmodelの数だけPromiseを用意してそれらがロードされるまでの間色々って感じにするだけ

// ん？

// それって全体の枠組みについての話なのでは...そうですよ。RenderNodeとかRenderNode2Dとは別の枠組みの話。そうよね。んー...

// wgexの部分は改名可能です
// じゃあfoxRendererにして。

//const foxRenderer = (function(){
//  ........
//  return ex;
//})();

// exはextraとかextendではないですね。exportのexですね。
// エイリアスはfoxで。

// この中にあれ、imageやmodelのロードどうするとか全部入れる。全体の構成とか。
// imageのロードはアドレス渡すとPromiseオブジェクトが生成されて配列に放り込まれて
// 一通り
// それがPromise.allで評価されて...
// その前に配列が長さ>0であればダミーキャンバスが生じてそこでloading...して
// それとは別に非同期処理でPromise.allのthenでsetupしてdrawして実行される
// timerが備え付けられてて自由に止めたり進めたりできる
// 感じ
// あとはインタラクション系かな...キー操作、マウス操作、タッチ操作。
// マウスとタッチは接触関連でいろいろ違いがあるので別の形で制御...


// もしくは



// 今のままp5の仕様を活かしながら色々やるでも、いいよ。

// まあ、環境整えるの面倒だし。その方がいいなら、それで。
// でも一度は自分で枠組み作るのも無駄じゃないと思うんだよね


/*
構成としては
foxRendererの中にwebglで色々やるためのRenderNode, 2dでいろいろやるためのRenderNode2D, そもそも全体の形を作るためのSystemを用意する。
基本的にはSystemをいじる形で色々やるってわけ
setupとdrawを定義してあとはよろしくよろしく～～～って感じで。

// スケッチイメージ

const fox = foxRenderer;
let nd; // RenderNodeもしくはRenderNode2D
const sys = new fox.System({fps:60とかそういうの}); // システムを作ります。この辺は実験的にもうやってる。
// timerが備え付けてあってそれ使ってnoLoop()とか実装するつもり
// foxの方でキーイベントの登録とかやる
// その中でsys.noLoop()とか指示すればよろしくやってくれるはずです（？？）

sys.initialize();
// これをconstructorに書くかどうかって割とあれなんだけど
// まああの、再初期化とかするかもしれないわけでそこら辺かなぁ

sys.loadImage("登録名でsysから呼び出し可能", "~~~~");
sys.loadModel("登録名でsysから呼び出し可能", "~~~~");

// RenderNodeにしてもRenderNode2Dにしても要するに「見える」もしくは「見えない」キャンバス要素を作る処理
// 結局のところ見えるか見えないかの違いしかないので従来のその、パフォーマンス見たいとか背景みたいとかの理由で
// 2Dグラフィックほしい～っていうのはRenderNode2Dで「見えない」のを作ってそれのコンテクストからcanvas取ってそれ渡して
// Textureオブジェクト作って、で、書き換えとかできるようにすればいいんだ。変更点はほぼ皆無。だって今もう出来てることを...んー。
// 見える、mainタグ内と、見えない、body内、っていう違いがあるだけ。

sys.setup = function(){
  ~~~~~
}
sys.draw = function(){
  ~~~~~
}
sys.execute(); // さあいけ！
*/

// どう？
// どうといわれても....

// imageの方は記事が見つかったからこんな感じかな...
// objの方は完了してもそのあとparseしないといけないからそれも終わってからでないとね...
// async使った方が楽に書けるのかしら
// 単純にonloadの中にパース関数書けばいいっぽいな
// こんなことに時間使うより...

// 2Dですが
// pixelDensityについて
// 要するに大きいサイズの方に描画してたんですよ、実際に。
// cssで決めたサイズに描画してもそうなるのはなぜか？
// scale使ってました。そういうことです。だからあれが2であればscaleで2倍して描画してたわけです。
// まじか...
// で、何でそういうことをするかって言ったらその方が精細に描画できるからで...

// saveについてはだめですね。描画領域に依存するぽい。当たり前か。

// obj...
// んー。

// Three.js すごい、ね。
// はぁ、。。。
// まあ、いいか。...
